\documentclass[a4paper,12pt]{report}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{indentfirst}
\usepackage{plantuml}
\usepackage{tikz}
\usepackage{aeguill}
\usepackage{float}
\usepackage{url}
\usepackage{hyperref}

% chktex-file 44

\newgeometry{
    top=2.5cm,
    bottom=3cm,
    inner=2cm,
    outer=2cm,
}

\pagestyle{fancy}
\fancypagestyle{plain}{}

\lhead{\scriptsize Computing and Information Technology\\
    2022\\
    David Daniel, Pava\\
    Walman: A Virtual Wallet Management System}
\rhead{\includegraphics[width=4cm]{images/logo_upt.jpg}}
\cfoot{- \thepage\ -}
\renewcommand{\headrulewidth}{0pt}

\setlength{\headheight}{44pt}

\fancypagestyle{titlepage}{
    \lhead{\footnotesize Computing and Information Technology\\\textbf{2022}}
    \rhead{\includegraphics[width=4cm]{images/logo_upt.jpg}}
    \cfoot{}
}

\titleformat{\chapter}{\center\normalfont\LARGE\bfseries\MakeUppercase}{\thechapter}{0.5em}{}
\titlespacing*{\chapter}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}
\title{\LARGE WALMAN\\{ A Virtual Wallet Management System}}

\titleformat{\section}{\normalfont\large\bfseries\MakeUppercase}{\thesection}{0.5em}{}
\titlespacing*{\chapter}{0pt}{3.5ex plus 1ex minus .2ex}{2.3ex plus .2ex}
\title{\LARGE WALMAN\\{ A Virtual Wallet Management System}}

\author{Candidate: David Daniel, Pava
    \\Coordinator: Assoc. Prof.\ Razvan, Bogdan}

\date{June 2022 Session}

\begin{document}

\begin{titlepage}
    \thispagestyle{titlepage}
    \begin{center}
        \vspace*{10cm}
        \LARGE\textbf{Walman\\A Virtual Wallet Management System}\\
        \vfill
    \end{center}
    \begin{flushleft}
        \large\textbf{Candidate: David Daniel, Pava
            \\Coordinator: Assoc. Prof.\ Razvan, Bogdan}
    \end{flushleft}

\end{titlepage}

\chapter*{Abstract}

\tableofcontents

\chapter{Introduction}
In this project I implemented a wallet manager in the form of a mobile
application. The main features are password management, password generation, qr
and barcode storage and management, crypto wallet and OTP token management. The
user has the option to backup the data either in the cloud or on the
blockchain. Once backed up, the data will be available to be restored.

\section{Context}

\par In the last 30 years, the number of tasks that are digitalized has increased
exponentially. The most important part of the security systems of these tasks
is user management and authentication. The password is the most widely spread
form of user authentication and thus is often the prime target of attackers
that want to impersonate someone else.

According to~\cite{systematicAnalysis}, a \textit{``systematic literature
    review in the area of passwords and passwords security''}, there are many
problems with password security and management ranging from weak passwords and
password reuse, to users writing down passwords or sending them through
unsecure channels. Most of these problems according
to~\cite{systematicAnalysis} are solved by using password recommendations. A
good solution to most of these problems is a password management tool. A
password manager is a piece of software designed for generating and managing
passwords, in this way the user can have unique, complex and safely stored
password without having to remember them.

Another great method to better secure you accounts is using a two factor
authentication (2FA) method. These method vary from security questions, to one
time passwords (OTP) sent from the server to the user via email or SMS, to OTPs
generated using specialized algorithms such as: HMAC-based One Time Password
(HOTP)\cite{hotp} and Time Based One Time Password (TOTP)\cite{totp}.

The cryptocurrency market is another area that has seen a considerable
development lately. As of May 2022, the market cap of Bitcoin is around 565
billion USD, and the market cap of Ethereum is around 214 billion USD.\@ In the
case of Bitcoin, that is more than double of what it was in 2019 (around 211
billion USD), referenced in~\cite{cryptocurrencyMarketAnalysis}.
Cryptocurrencies also offer secure and long term storage capabilities thanks to
the blockchain technology. Blockchain backups, thanks to the decentralized
nature of the blockchain, are very hard to be tempered with. A traditional
cloud backup could be lost or inaccessible in more than one situations. The
most obvious one is data loss happening as result of a cyber attack or the
company simply going bankrupt. There are also situations in which the company
itself can refuse to serve you anymore. They can freeze your account or just
refuse to serve an entire country all-together, we have the recent example of
companies like Visa and Mastercard refusing to serve russian citizens as result
of political tensions as described in~\cite{russiaSanctions}
and~\cite{russiaSanctions2}. All these scenarios cannot happen in a
decentralized blockchain system.

Businesses that were traditionally not online like shopping also have inversely
digitalized. Nowadays most of the hypermarkets offer fidelity cards. Usually
these cards are built around a unique barcode or qr code. Often it's hard to
manage all your cards, so a digital storage solution to solve this issue would
help the end user better manage their cards.

Considered all mentioned above, a user has to remember and manage a lot of
information in order to interact with the currently available online
infrastructure. A tool that could help them manage all this data better is a
wallet manager.

\section{Motivation}

My personal motivation for creating a wallet manager is the fact that I want to
use it myself. Also I wanted for a long time to explore the state of the art in
smart contract development, so this was a great occasion to do so.

I chose to create this project in the form of a mobile application since people
tend to have their smartphones with them most of the time, so having a virtual
wallet on your mobile device makes sense.

Another factor that motivates me is the fact that currently in the mobile
application market there are almost no free and open source password management
applications available. The user needs to \textit{trust} the creators of the
application with their data, not knowing how the implementation of the product
is made, they have no guarantee that the data is safe.

\section{Similar Products Available on the Market}

There are a lot of password managers available on the market. In this section
we are going to try to make a comparison between some of the most popular
options available.

\begin{table}[h!]
    \centering
    \begin{tabular}{ | l | l | l | l | l | l | }
        \hline
        \textbf{Property}           & \textbf{LastPass} & \textbf{RememBear} & \textbf{KeePass} & \textbf{PassMan} & \textbf{KeyBase} \\
        \hline
        \textbf{Mobile Version}     & Yes               & Yes                & No               & Yes              & Yes              \\
        \hline
        \textbf{Blockchain Storage} & No                & No                 & No               & No               & Yes              \\
        \hline
        \textbf{Price}              & \$3/month         & \$6/month          & Free             & Free             & Free             \\
        \hline
        \textbf{License}            & Proprietary       & Proprietary        & GPL-2.0          & AGPL-3.0         & BSD-3            \\
        \hline
    \end{tabular}
    \caption{A comparison between some of the most popular password managers.}\label{tab:otherProducts}
\end{table}

In \autoref{tab:otherProducts} we have a comparison between some of the most
popular password managers available on the market. First off we have
LastPass\cite{lastpass} and RememBear\cite{remembear}, two very similar
password managers, both having a free and a payed plan. Neither of these two is
open source, so the most pressing issue regarding them is the guarantee that
your data is safe. Without having the ability to see how your data is managed
and stored you cannot be certain that it is secure. Also these applications do
not have blockchain backups.

KeePass\cite{keepass} is probably the most popular password manager for
desktop. It is free and open source, and the code was analyzed and certified by
specialized organizations such as the Open Source Initiative. The biggest
drawback to KeePass is the aged user interface and the missing mobile
application counterpart. Nowadays a lot of the situations where a user needs
access to their credentials are happening while using smartphones. Also the
features are limited, KeePass doing one thing and doing it well that being
password management. There are no cloud or blockchain backups, so the user
needs to manager backing up and storing their password database themselves.

Similar with KeePass, PassMan\cite{passman} is a free and open source password
manager. They have a mobile version of the application, but blockchain backups
are missing. Also, again, PassMan is just a password manager. It does not
manage shopping cards or crypto wallets.

Last but not least there is KeyBase\cite{keybase} which is not technically a
password manager. KeyBase is a blockchain, decentralized, social media
application. You can store password and secure notes inside the application but
from the user experience point of view, KeyBase was never designed to be a
password or wallet manager. The reason why it is mentioned, is because KeyBase
is implemented on the blockchain, all user data is encrypted and it's free and
open source.

\chapter{Technology Stack}

In this chapter I am going to describe the technologies used. The application
has 3 main components. The first component is the frontend, a mobile
application. The second one is the cloud storage backend. The last part are the
smart contracts deployed on the blockchain.

\section{Frontend}

The most important aspects I considered when I chose the technologies used for
the frontend was cross-platform capabilities, ease of testing, documentation
availability and performance. This is why for this project I chose a Flutter
stack.

\subsection{Flutter}

Flutter\cite{flutterDocs} is a mobile application development framework
developed by Google in the Dart programming language. It was released in May
2017 and it currently is one of the most popular mobile development frameworks.

According to \textit{``An empirical investigation of performance overhead in
    cross-platform mobile development frameworks''}\cite{flutterPerformance},
Flutter has one of the better resource management systems when compared with
other popular mobile development frameworks.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{images/flutterPerformance/ram.png}
    \caption{Boxplot from~\cite{flutterPerformance} of RAM usage across all tests done in~\cite{flutterPerformance} }\label{fig:flutterPerformanceRAM}
\end{figure}

As seen in~\autoref{fig:flutterPerformanceRAM}, on average Flutter outperforms
most of the other frameworks in memory management.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{images/flutterPerformance/cpu.png}
    \caption{Boxplot from~\cite{flutterPerformance} of CPU usage across all tests done in~\cite{flutterPerformance} }\label{fig:flutterPerformanceCPU}
\end{figure}

In~\autoref{fig:flutterPerformanceCPU} we have a comparison between CPU usage
of similar applications implemented in different frameworks
in~\cite{flutterPerformance}, where Flutter achieves a competitive result when
compared to the other frameworks.

Another very important feature of Flutter is cross-platform compatibility. A
mobile application developed in this framework can be build in native Android
and IOS applications with minimal performance loss. There is also Flutter Web
for web applications, offering the option to create a browser variant of the
application in the future, reusing already developed and tested parts from the
mobile application.

Flutter comes with a very rich and detailed documentations, the Flutter
Docs\cite{flutterDocs} and a set of development plugins for the most used IDE
and text editors such as Android Studio, Intellij or Visual Studio Code. During
the development process the code is executed into a runtime environment,
allowing almost instant compilation times speeding up the development, and in
production, the code is compiled into a native application for performance
enhancement.

The User Interface in Flutter is build based on a widget tree, similar to
React. Every User Interface item inherits the Widget class.

\subsection{Dart}\label{chapter:dart}

Dart\cite{dartDocs} is a general purpose programming language developed by
Google starting with 2011. It was intended to replace JavaScript and TypeScript
for frontend applications, but instead, later, it was used to create the
Flutter framework.

Dart is a type safe, C-like programming language. It can be both interpreted by
a runtime or compiled. The memory management is handled by a garbage collector
similar with Python or JavaScript.

One of the strongest features of Dart is the compiler. It can be compiled in
binary code, JavaScript or mobile native code such as Java and Kotlin for
Android and Objective-C and Swift for IOS devices. Dart also performs tree
shaking at compile time, discarding unused objects, methods and functions.

\subsection{Code Generation}

During the development of the project I used multiple packages (dart libraries)
in the process. One very important package that needs to be mentioned is the
\textit{freezed} package\cite{freezedDocs}. This offers code generation for
common model functionalities such as json encoders and decoders, copyWith
methods, different constructors and access functions and more.

Classes generated by the package are annotated with the \textit{@freezed} tag.
The generated code is stored into files that contain the \textit{.freezed.dart}
and \textit{.g.dart} extensions.

\subsection{State Management}

One of the most important aspects of frontend application development is state
management architecture. There are a lot of different state management patterns
available in Flutter\cite{flutterStateManagement} such as Provider, BLoC or the
simple setState. These state management patterns tell the application when the
state has changed and when certain components of the presentation layer (the UI
of the application) needs to be updated as a result of that.

For this project I used the Redux state management architecture. This pattern
is a very popular solution for managing the state of an application, and it is
commonly used in web development. There is an implementation for it in Flutter
in the packages: flutter\_redux\cite{flutterReduxDocs}, redux\cite{reduxDocs}
and redux\_epics\cite{reduxEpicsDocs}.

\begin{figure}[H]
    \centering
    \scalebox{0.75}{\input{diagrams/component/redux.latex}}
    \caption{Basic structure of a Redux State Management System}\label{fig:reduxArchitecture}
\end{figure}

In~\autoref{fig:reduxArchitecture} we can see the core structure of the redux
architecture I used in the project. A state change begins the dispatch of an
action. They are usually triggered by the user interface, but in some cases
they can be triggered by an API event. The Epics are a set of listeners which
analyze the action stream. When an Epic recognizes an Action, it performs a
series of operations which can process the data using the APIs (business logic)
or dispatch new actions. Every action is also watched by the Reducer, which
listens for Actions and changes the State accordingly. When the State changes,
the Widgets (in case of Flutter) that depend on the elements updated in the
State, are triggered to pe updated.

In order to access specific elements of the state, and not update every widget,
every time the state changes. Containers can be used to access a specific part
of the state. In order to access the State, the User Interface needs to request
it from the Store, in this way, the Store knows when to redraw the object. The
widgets that update when the state is modified and have access to the Store are
part of the flutter\_redux package\cite{flutterReduxDocs}.

Error handling in redux is made using special stream functions from the RxDart
package\cite{rxDartDocs}. RxDart offers and extension to the functional
capabilities of dart. In redux the application is represented as a stream of
actions. In order to make error handling efficiently, every action sequence
spawns a new stream. In case of an exception, the stream will have an exception
and we can dispatch a new Action with relevant information about the error. In
this way the probability of total application wide runtime exceptions is
dramatically lowered.

\section{Firebase}

In this section I am going to describe the technologies used for the creation
of the cloud storage server portion of the application. In order to use the
cloud storage, the user needs to create an account. After the account is
created, the user needs to have the ability to create backup entries and
restore previous backups.

Firebase\cite{firebaseDocs} is an app development platform created by Google,
designed as a backend for mobile and web applications. Firebase offers already
implemented solutions for user management, artificial intelligence integration
and databases. A firebase backend is hosted by Google in a ``pay as you use''
monetization scheme.

For this project I chose to use the services provided by Firebase to implement
the cloud storage part of the project, mainly for ease of deployment, the good
integration with Flutter throughout the dedicated packages and reduced costs
(so far free).

The user management uses the email and password login service provided by
Firebase. Once a user account is created, a database entry is also made, access
to this database being restricted to the user base on their unique identifier.

For the storage, Firebase provides two different services. The first one is
Real Time Database, which is a NoSQL type database, that resembles a Json type
file. There are drawbacks to the Real Time Database such as low fragmentation
which increases the data transfer size between the client and the server. A
solution to this problem is the second service, Firestore, which is also a
NoSQL type database similar with Real Time Database but it has some additional
features. Firestore is structured into collections of documents which each have
multiple fields of different types. This approach allows the client a more
granular access to the data, reducing the size of files transferred between the
client and the server and client side processing.

\section{Blockchain}

For the Blockchain storage of the application I used the Ethereum smart
contract development stack with Solidity. In this chapter I am going to explain
the basic logic behind the blockchains, how smart contracts are built into them
and the economy between smart contract deployment and usage.

\subsection{What is a Blockchain?}

The blockchain is the basic structure that sits at the base of most of the
cryptocurrencies. At it's core, it is a decentralized, distributed system of
data storage and processing.

\begin{figure}[H]
    \centering
    \scalebox{1}{\input{diagrams/deployment/block.latex}}
    \caption{The structure of a block as described by the Ethereum documentation\cite{ethereumDocs}}\label{fig:block}
\end{figure}

The blockchain is made up of a list of blocks connected to each other. Every
block contains a set of information about itself and a reference to the
previous block, the \textit{parentHash} field in case of Ethereum, in the form
of a hash as described in~\autoref{fig:block}. The \textit{parentHash} of the
current block is the \textit{mixHash} of the previous block.

The \textit{mixHash} is the digest of a hashing algorithm of the entire content
of the block. The \textit{mixHash} needs to have the first two bytes 0, in
order to be considered mined. This is achieved by incrementing the
\textit{nonce} field until the target \textit{mixHash} is reached.

For the hashing algorithm, Ethereum was developed using the Keccak-256 hashing
function, which was later standardized as SHA-3 in~\cite{sha3}.

The block also has the \textit{timestamp} when it was mined and the
\textit{stateRoot} which contains metadata about the current state of the
system.

Information about the difficulty of the mining process and the respective price
of the process are also stored in the block, in the \textit{difficulty} and
\textit{baseFeePerGas} fields.

The \textit{transactions} field contains information about the transactions
associated with the block and the optional data exchanged. This is the place
where the smart contract logic is deployed and later interacted with.

A successfully mined block is added to the blockchain and then the transaction
is confirmed by every subsequent blocks.

\begin{figure}[H]
    \centering
    \scalebox{1.1}{\footnotesize\input{diagrams/object/blockchain.latex}}
    \caption{High level relationship between two blocks}\label{fig:blockchain}
\end{figure}

In~\autoref{fig:blockchain} the relationship between two blocks is represented.
As stated before, \textit{block 2} has the mixHash of \textit{block 1} in it's
parentHash field. In this example, \textit{block 1} being the first block in
the blockchain has the null value as parentHash.

If the data in \textit{block 1} was to be changed, it would invalidate the
mixHash of \textit{block 1}. The mixHash would have to be mined again, but then
it will be different thant the parentHash of \textit{block 2}, therefore
invalidating the blockchain. This is the first mechanism of defense against
malicious data manipulation. There cannot be changes in any previous blocks of
the blockchain without invalidating every block starting from the change.

The blocks following a changed block can be mined again in order to re-validate
the blockchain. Here is where the second line of defense comes in,
distribution. Every chain is stored on multiple nodes, therefore a change in
one has to be reflected in all of them. This makes data alteration nearly
impossible.

\subsection{Ethereum}

Ethereum is one of the most popular cryptocurrencies. Other than the popularity
and the implicit high amount of resources that is implied, and unlike other
popular cryptocurrencies like Bitcoin, Ethereum offers the ability to run code
on the blockchain using the Ethereum Virtual Machine (EVM)\cite{ethereumDocs}.

Every execution on the Ethereum Virtual Machine requires Gas, which is an
amount of Ethereum cryptocurrency units (ETH) proportional with the complexity
and the memory requirements of the task. Since the cost of an ETH has raised
dramatically over the last 5 years, subdivisions of the currently were created.
The two most widely used subdivisions are \textit{wei} (\(10^{-18}\) ETH) and
\textit{gwei} (\(10^{-9}\) ETH).

Since the development of a blockchain application implies a lot of testing and
prototyping, solutions of simulating the blockchain were created. Ganache is
such a software developed in JavaScript, it simulates an Ethereum blockchain on
a local machine or on a server. For this project I tinkered with Ganache but
later I decided to go one step further and deploy my contracts on an Ethereum
Testnet.

Ethereum Testnets are networks similar with the main Ethereum network
(mainnet), designed to provide a free of charge development environment
identical with the mainnet. Testnets are blockchains that run in parallel with
the mainnet, having the same functionalities and features. There are a lot of
Ethereum Testnets like: Ropsten, Kovan or Goerli. In this project I worked with
the Rinkeby network. Unlike on the mainnet, ETH is generated constantly on the
Testnets and it is distributed to any wallet that requests it via faucets.
There are no costs involved with developing a blockchain application on a
Testnet. After the development process is complete, in production the
application can be easily redeployed on the mainnet.

\subsection{Smart Contracts}

The code that can be executed by the Ethereum Virtual Machine has to be
compiled into a specific binary code. Smart contracts are transactions that
contain binary code that can be later executed from subsequent transactions.
Gas cost afferent to the execution of the contract is payed by the transaction
that wants to execute the contract, not the contract itself. Therefore in order
to create a blockchain application, one of the requirements of such a program
is having an attached cryptocurrency wallet. In the case of server
applications, this wallet can be a server secret, managed by the administrator,
but in the case of client applications, the wallet cannot be incorporated by
default into the application, since that would mean that everyone has access to
it and is able to act maliciously. This is is the reason why this project
requires an integrated wallet. An external wallet can also be used, but it
would deteriorate the user experience.

Once a smart contract is deployed, it cannot be changed, therefore testing such
a contract for vulnerabilities and bugs is essential.

One very important aspect of blockchain applications is gas efficiency. Certain
operations consume more gas than others, and storing data also consumes gas.
The application should be optimized to leave a minimal data footprint focusing
on using non persistent memory.

Accessing data from a smart contract is free of charge. As long as there is no
new data to be stored or there is no code to be executed, accessing the data in
a smart contract is cost free.

A very important security aspect of smart contracts and blockchains in general
is that data is always visible by anyone who accesses the blockchain and it
cannot be modified. Therefore sensitive data needs to be encrypted.

\subsection{Solidity}

Solidity\cite{solidityDocs} is a dedicated programming language for blockchain
applications. It was designed specifically for the creation of smart contracts.
This language is an object oriented, compiled language that resembles C++ and
JavaScript.

Code written in Solidity is compiled into binary code that can be executed on
the Ethereum Virtual Machine and there are specific modifiers for the
interaction with the EVM and code optimization. Some of these modifiers are:
\textit{view} which specifies that the afferent function is forbidden from
changing the state and \textit{payable} which allows ETH to be transferred with
the function call. There are also more commonly used modifiers like:
\textit{override}, \textit{virtual}, \textit{private} or \textit{public}.

\section{Development Environment}

For the creation of this project I used a wide variety of tools. They range
from Integrated Development Environments (IDEs) to task management
applications.

For the development of the mobile application I used Intellij and Visual Studio
Code with the Flutter specific plugins. I also used Adobe XD for user interface
design and plantuml for diagrams. In order to test the application, I used the
Android Virtual Machine provided by Android Studio.

For the blockchain part of the application I wrote the smart contracts using
Solidity. I created a python compilation script for the smart contracts that is
also used in the testing pipeline.

For the cloud portion I used the Firebase console and the specific packages for
Flutter.

All the code was managed using the Git software versioning system and it was
deployed on Github at \url{https://github.com/dvpv/walman}. I used the Github
Actions feature in order to manage the two test pipelines for the mobile
application and blockchain smart contracts.

The smart contracts were deployed on the Rinkeby Testnet using the Remix
Ethereum IDE, and in order to access them from the mobile application, the
web3dart\cite{web3dartDocs} flutter package was used.

For task management I used Focalboard, a free and open source alternative to
Trello.

\chapter{Implementation}

\section{Use Cases}

The application has six main components: the password, qr and barcode, OTP and
crypto-wallet managers and the cloud and blockchain backup solutions.

\begin{figure}[H]
    \centering
    \scalebox{0.45}{\large\input{diagrams/usecase/usecase.latex}}
    \caption{Principal use cases of the application}\label{fig:useCase}
\end{figure}

In~\autoref{fig:useCase} the main use cases of the application are depicted.

The entire application is locked and encrypted using the mater key. If a master
key was not set yet, in the case of a first time launch of the application, the
user is prompted to create a new master key. After the application is unlocked,
the user has access to multiple functionalities and features.

The home page of the application shows in a short format the passwords, codes
and wallet balance. The user can navigate to different pages for each of the
functionalities.

The passwords page, shows the user a list with the passwords that are currently
stored into the database. Here the user has the option to add, edit or remove
passwords.

The codes page is similar with the passwords page, the user has the ability to
scan new codes, view existing ones and delete them.

On the OTP page, the user can see the currently stored one time passwords. The
codes are updated every second and a timer representing the remaining time in
which the current code is valid is displayed.

On the wallet page, the user can see the current balance of the wallet and the
public address. The only transactions that can be made with this wallet are
blockchain backup operations.

The sync page shows all available cloud and blockchain backups. The use has the
option to restore a backup, or create new ones.

In order to create a blockchain backup the user needs to have a crypto wallet.
If there is no crypto wallet created, the user has the option to import one by
private key or create a new one. For the backup to work, the wallet needs to
have enough currency in it in order to pay for the gas price. Restoring a
backup requires no gas payment. Crypto wallets are not backed up on blockchain
backups and neither they are on cloud backups.

For a cloud backup to be created the usr needs to be logged into a cloud
account. If the user is not yet logged in, they can create new account, or
login into an existing one.

On the settings page, the user can manage the cloud account and view and delete
the wallet private key.

There is an app-wide search button which displays results from the entire
application. If the user clicks on one of the results, they will be redirected
to the respective page in order to view the content.

\newpage
\section{System Architecture}

The system in composed out of three main components. The communication between
these components is made exclusively using the HTTPS protocol.

\begin{figure}[H]
    \centering
    \scalebox{0.499}{\large\input{diagrams/component/system.latex}}
    \caption{High level system architecture}\label{fig:system}
\end{figure}

In~\autoref{fig:system} a high level representation of the system is depicted
into a component diagram. The user can directly interact only with the mobile
application. The Firebase component is deployed online in the cloud platform
provided by google and the smart contract is deployed on the Ethereum
blockchain.

The mobile application is the first component and it is the only component that
initiates data exchange in the system. It has three API sub components for each
of the online services it needs to communicate with and one API for interaction
with the Secure Storage.

The Secure Storage (or Secure Enclave on IOS) is a special persistent memory
zone created to store sensitive information on a mobile device. I used the
Secure Storage to save the part of the application state that needs to be
recovered at each application start.

The middleware consists of the redux epics defined into the application. The
epics are the only part of the mobile application which has access to the
external APIs.

The user interface interacts with the middleware by dispatching redux actions.
The state of the application is updated by the reducer when it detects specific
action events that require a state update. The user interface code is
completely separated from the APIs, the only connection being the middleware.

\section{Application Flow}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.23]{diagrams/state/flow.png}
    \caption{Flow diagram showing the main pages and fragments of the application}\label{fig:flow}
\end{figure}

In~\autoref{fig:flow} we can see the flow between the main elements of the user
interface. Initially the user needs to input the master key in order to unlock
the application or create one if it does not exist.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{images/app/home.png}
    \caption{Home fragment of the application}\label{fig:homepage}
\end{figure}

After the application is unlocked the user is redirected to the Home
fragment,~\autoref{fig:homepage}, of the Index page. Here the user has quick
access to passwords, codes and the wallet balance. The user can navigate
different fragments using the bottom navigation bar. The passwords fragment
contains a list with all the passwords. Here the user can copy the passwords if
they tap on the copy button of a password. On long tap a context menu giving
the user the delete, edit and copy options shows up. On tap a password opens a
details page containing information about the password. From this page the user
can go to the edit page where they can change the data related to the selected
password.

The Codes fragment is similar with the password page. It shows a list that
contains all the codes. If the user taps on a code, a details page will be
opened showing a big picture of the code and it's content. The user can delete
the code in the details page or in the Codes fragment by log tapping and
selecting the delete option in the context menu.

The OTP fragment shows a list containing all the stored tokens and the current
code for each. If the user taps on one of these list entries the code will be
copied to the clipboard. The user can delete an OTP token by selecting the
delete option from the context menu after a long tap on a token.

The last fragment is the Wallet. Where if there is no wallet created yet, the
user can create a new wallet or import one by introducing the private key. When
a wallet exists the balance of the wallet and the public address are displayed.

On the top right of the Index Page there is a menu, seen
in~\autoref{fig:homepage}. This menu offers the user the option to open the
sync page, the settings page or the password generator.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{images/app/sync.png}
    \caption{Sync page of the application}\label{fig:syncpage}
\end{figure}

The sync page,~\autoref{fig:syncpage}, contains a list with all the available
backups the user can restore. A backup can be restored by pressing the restore
button of the desired backup. Every backup has the number of items displayed
and also the date and time when it was created is also shown. The backups are
sorted chronologically, the most recent ones being at the top. The blockchain
backups are represented by an infinity icon and the cloud ones by ca cloud
icon.

In case there are no backups available the user is prompted with the option to
create one instead of being shown an empty list. The user can also create a
backup by selecting the appropriate option form the top right menu.

If the user tries to create a blockchain backup but there is no wallet set,
they are redirected to the wallet fragment of the index page. Where they are
prompted to create or import a wallet.

Similar, in the case when the user wants to create a cloud backup but they are
not logged into a cloud account, they are redirected to the login page and
prompted to login or signup for the cloud service. After the login process is
done they are redirected back to the sync page and a cloud backup can now be
created.

\section{Password Management}

\section{QR and Barcode Management}

\section{OTP Authenticator}

\subsection{HOTP}

\subsection{TOTP}

\section{Cryptocurrency Wallet}

\section{Backup}

\subsection{Cloud Backup}

\subsection{Blockchain Backup}

\section{Security}

\chapter{Tests}

\section{Test Pipeline}

\section{Unit Tests}

\section{Widget Tests}

\section{Performance Statistics}

\chapter{Conclusions}

\section{Possible Improvements}

\bibliographystyle{plain}
\bibliography{references}
\addcontentsline{toc}{chapter}{Bibliography}

\end{document}