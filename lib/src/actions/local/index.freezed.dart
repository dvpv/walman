// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'index.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$CreateNewPasswordTearOff {
  const _$CreateNewPasswordTearOff();

  CreateNewPassword$ call(Password password, String masterKey) {
    return CreateNewPassword$(
      password,
      masterKey,
    );
  }
}

/// @nodoc
const $CreateNewPassword = _$CreateNewPasswordTearOff();

/// @nodoc
mixin _$CreateNewPassword {
  Password get password => throw _privateConstructorUsedError;
  String get masterKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateNewPasswordCopyWith<CreateNewPassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewPasswordCopyWith<$Res> {
  factory $CreateNewPasswordCopyWith(CreateNewPassword value, $Res Function(CreateNewPassword) then) =
      _$CreateNewPasswordCopyWithImpl<$Res>;
  $Res call({Password password, String masterKey});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$CreateNewPasswordCopyWithImpl<$Res> implements $CreateNewPasswordCopyWith<$Res> {
  _$CreateNewPasswordCopyWithImpl(this._value, this._then);

  final CreateNewPassword _value;
  // ignore: unused_field
  final $Res Function(CreateNewPassword) _then;

  @override
  $Res call({
    Object? password = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_value.copyWith(
      password: password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc
abstract class $CreateNewPassword$CopyWith<$Res> implements $CreateNewPasswordCopyWith<$Res> {
  factory $CreateNewPassword$CopyWith(CreateNewPassword$ value, $Res Function(CreateNewPassword$) then) =
      _$CreateNewPassword$CopyWithImpl<$Res>;
  @override
  $Res call({Password password, String masterKey});

  @override
  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$CreateNewPassword$CopyWithImpl<$Res> extends _$CreateNewPasswordCopyWithImpl<$Res>
    implements $CreateNewPassword$CopyWith<$Res> {
  _$CreateNewPassword$CopyWithImpl(CreateNewPassword$ _value, $Res Function(CreateNewPassword$) _then)
      : super(_value, (v) => _then(v as CreateNewPassword$));

  @override
  CreateNewPassword$ get _value => super._value as CreateNewPassword$;

  @override
  $Res call({
    Object? password = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(CreateNewPassword$(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateNewPassword$ implements CreateNewPassword$ {
  const _$CreateNewPassword$(this.password, this.masterKey);

  @override
  final Password password;
  @override
  final String masterKey;

  @override
  String toString() {
    return 'CreateNewPassword(password: $password, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateNewPassword$ &&
            const DeepCollectionEquality().equals(other.password, password) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(password), const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  $CreateNewPassword$CopyWith<CreateNewPassword$> get copyWith =>
      _$CreateNewPassword$CopyWithImpl<CreateNewPassword$>(this, _$identity);
}

abstract class CreateNewPassword$ implements CreateNewPassword {
  const factory CreateNewPassword$(Password password, String masterKey) = _$CreateNewPassword$;

  @override
  Password get password;
  @override
  String get masterKey;
  @override
  @JsonKey(ignore: true)
  $CreateNewPassword$CopyWith<CreateNewPassword$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$CreateNewCodeTearOff {
  const _$CreateNewCodeTearOff();

  CreateNewCode$ call(Code code, String masterKey) {
    return CreateNewCode$(
      code,
      masterKey,
    );
  }
}

/// @nodoc
const $CreateNewCode = _$CreateNewCodeTearOff();

/// @nodoc
mixin _$CreateNewCode {
  Code get code => throw _privateConstructorUsedError;
  String get masterKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateNewCodeCopyWith<CreateNewCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewCodeCopyWith<$Res> {
  factory $CreateNewCodeCopyWith(CreateNewCode value, $Res Function(CreateNewCode) then) =
      _$CreateNewCodeCopyWithImpl<$Res>;
  $Res call({Code code, String masterKey});

  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$CreateNewCodeCopyWithImpl<$Res> implements $CreateNewCodeCopyWith<$Res> {
  _$CreateNewCodeCopyWithImpl(this._value, this._then);

  final CreateNewCode _value;
  // ignore: unused_field
  final $Res Function(CreateNewCode) _then;

  @override
  $Res call({
    Object? code = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_value.copyWith(
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $CodeCopyWith<$Res> get code {
    return $CodeCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

/// @nodoc
abstract class $CreateNewCode$CopyWith<$Res> implements $CreateNewCodeCopyWith<$Res> {
  factory $CreateNewCode$CopyWith(CreateNewCode$ value, $Res Function(CreateNewCode$) then) =
      _$CreateNewCode$CopyWithImpl<$Res>;
  @override
  $Res call({Code code, String masterKey});

  @override
  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$CreateNewCode$CopyWithImpl<$Res> extends _$CreateNewCodeCopyWithImpl<$Res>
    implements $CreateNewCode$CopyWith<$Res> {
  _$CreateNewCode$CopyWithImpl(CreateNewCode$ _value, $Res Function(CreateNewCode$) _then)
      : super(_value, (v) => _then(v as CreateNewCode$));

  @override
  CreateNewCode$ get _value => super._value as CreateNewCode$;

  @override
  $Res call({
    Object? code = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(CreateNewCode$(
      code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateNewCode$ implements CreateNewCode$ {
  const _$CreateNewCode$(this.code, this.masterKey);

  @override
  final Code code;
  @override
  final String masterKey;

  @override
  String toString() {
    return 'CreateNewCode(code: $code, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateNewCode$ &&
            const DeepCollectionEquality().equals(other.code, code) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(code), const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  $CreateNewCode$CopyWith<CreateNewCode$> get copyWith =>
      _$CreateNewCode$CopyWithImpl<CreateNewCode$>(this, _$identity);
}

abstract class CreateNewCode$ implements CreateNewCode {
  const factory CreateNewCode$(Code code, String masterKey) = _$CreateNewCode$;

  @override
  Code get code;
  @override
  String get masterKey;
  @override
  @JsonKey(ignore: true)
  $CreateNewCode$CopyWith<CreateNewCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$DeleteCodeTearOff {
  const _$DeleteCodeTearOff();

  DeleteCode$ call(String id) {
    return DeleteCode$(
      id,
    );
  }
}

/// @nodoc
const $DeleteCode = _$DeleteCodeTearOff();

/// @nodoc
mixin _$DeleteCode {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeleteCodeCopyWith<DeleteCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteCodeCopyWith<$Res> {
  factory $DeleteCodeCopyWith(DeleteCode value, $Res Function(DeleteCode) then) = _$DeleteCodeCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$DeleteCodeCopyWithImpl<$Res> implements $DeleteCodeCopyWith<$Res> {
  _$DeleteCodeCopyWithImpl(this._value, this._then);

  final DeleteCode _value;
  // ignore: unused_field
  final $Res Function(DeleteCode) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $DeleteCode$CopyWith<$Res> implements $DeleteCodeCopyWith<$Res> {
  factory $DeleteCode$CopyWith(DeleteCode$ value, $Res Function(DeleteCode$) then) = _$DeleteCode$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class _$DeleteCode$CopyWithImpl<$Res> extends _$DeleteCodeCopyWithImpl<$Res> implements $DeleteCode$CopyWith<$Res> {
  _$DeleteCode$CopyWithImpl(DeleteCode$ _value, $Res Function(DeleteCode$) _then)
      : super(_value, (v) => _then(v as DeleteCode$));

  @override
  DeleteCode$ get _value => super._value as DeleteCode$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(DeleteCode$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeleteCode$ implements DeleteCode$ {
  const _$DeleteCode$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'DeleteCode(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteCode$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  $DeleteCode$CopyWith<DeleteCode$> get copyWith => _$DeleteCode$CopyWithImpl<DeleteCode$>(this, _$identity);
}

abstract class DeleteCode$ implements DeleteCode {
  const factory DeleteCode$(String id) = _$DeleteCode$;

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  $DeleteCode$CopyWith<DeleteCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$DeletePasswordTearOff {
  const _$DeletePasswordTearOff();

  DeletePassword$ call(String id) {
    return DeletePassword$(
      id,
    );
  }
}

/// @nodoc
const $DeletePassword = _$DeletePasswordTearOff();

/// @nodoc
mixin _$DeletePassword {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeletePasswordCopyWith<DeletePassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeletePasswordCopyWith<$Res> {
  factory $DeletePasswordCopyWith(DeletePassword value, $Res Function(DeletePassword) then) =
      _$DeletePasswordCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$DeletePasswordCopyWithImpl<$Res> implements $DeletePasswordCopyWith<$Res> {
  _$DeletePasswordCopyWithImpl(this._value, this._then);

  final DeletePassword _value;
  // ignore: unused_field
  final $Res Function(DeletePassword) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $DeletePassword$CopyWith<$Res> implements $DeletePasswordCopyWith<$Res> {
  factory $DeletePassword$CopyWith(DeletePassword$ value, $Res Function(DeletePassword$) then) =
      _$DeletePassword$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class _$DeletePassword$CopyWithImpl<$Res> extends _$DeletePasswordCopyWithImpl<$Res>
    implements $DeletePassword$CopyWith<$Res> {
  _$DeletePassword$CopyWithImpl(DeletePassword$ _value, $Res Function(DeletePassword$) _then)
      : super(_value, (v) => _then(v as DeletePassword$));

  @override
  DeletePassword$ get _value => super._value as DeletePassword$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(DeletePassword$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeletePassword$ implements DeletePassword$ {
  const _$DeletePassword$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'DeletePassword(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeletePassword$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  $DeletePassword$CopyWith<DeletePassword$> get copyWith =>
      _$DeletePassword$CopyWithImpl<DeletePassword$>(this, _$identity);
}

abstract class DeletePassword$ implements DeletePassword {
  const factory DeletePassword$(String id) = _$DeletePassword$;

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  $DeletePassword$CopyWith<DeletePassword$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$EditPasswordTearOff {
  const _$EditPasswordTearOff();

  EditPasswordStart start(Password password, {String pendingId = _kEditPasswordPendingId}) {
    return EditPasswordStart(
      password,
      pendingId: pendingId,
    );
  }

  EditPasswordSuccessful successful([String pendingId = _kEditPasswordPendingId]) {
    return EditPasswordSuccessful(
      pendingId,
    );
  }

  EditPasswordError error(Object error, StackTrace stackTrace, [String pendingId = _kEditPasswordPendingId]) {
    return EditPasswordError(
      error,
      stackTrace,
      pendingId,
    );
  }
}

/// @nodoc
const $EditPassword = _$EditPasswordTearOff();

/// @nodoc
mixin _$EditPassword {
  String get pendingId => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EditPasswordCopyWith<EditPassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordCopyWith<$Res> {
  factory $EditPasswordCopyWith(EditPassword value, $Res Function(EditPassword) then) =
      _$EditPasswordCopyWithImpl<$Res>;
  $Res call({String pendingId});
}

/// @nodoc
class _$EditPasswordCopyWithImpl<$Res> implements $EditPasswordCopyWith<$Res> {
  _$EditPasswordCopyWithImpl(this._value, this._then);

  final EditPassword _value;
  // ignore: unused_field
  final $Res Function(EditPassword) _then;

  @override
  $Res call({
    Object? pendingId = freezed,
  }) {
    return _then(_value.copyWith(
      pendingId: pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $EditPasswordStartCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory $EditPasswordStartCopyWith(EditPasswordStart value, $Res Function(EditPasswordStart) then) =
      _$EditPasswordStartCopyWithImpl<$Res>;
  @override
  $Res call({Password password, String pendingId});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$EditPasswordStartCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements $EditPasswordStartCopyWith<$Res> {
  _$EditPasswordStartCopyWithImpl(EditPasswordStart _value, $Res Function(EditPasswordStart) _then)
      : super(_value, (v) => _then(v as EditPasswordStart));

  @override
  EditPasswordStart get _value => super._value as EditPasswordStart;

  @override
  $Res call({
    Object? password = freezed,
    Object? pendingId = freezed,
  }) {
    return _then(EditPasswordStart(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      pendingId: pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc

@Implements<ActionStart>()
class _$EditPasswordStart implements EditPasswordStart {
  const _$EditPasswordStart(this.password, {this.pendingId = _kEditPasswordPendingId});

  @override
  final Password password;
  @JsonKey()
  @override
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.start(password: $password, pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditPasswordStart &&
            const DeepCollectionEquality().equals(other.password, password) &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(password), const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  $EditPasswordStartCopyWith<EditPasswordStart> get copyWith =>
      _$EditPasswordStartCopyWithImpl<EditPasswordStart>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return start(password, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return start?.call(password, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(password, pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return start(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return start?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(this);
    }
    return orElse();
  }
}

abstract class EditPasswordStart implements EditPassword, ActionStart {
  const factory EditPasswordStart(Password password, {String pendingId}) = _$EditPasswordStart;

  Password get password;
  @override
  String get pendingId;
  @override
  @JsonKey(ignore: true)
  $EditPasswordStartCopyWith<EditPasswordStart> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordSuccessfulCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory $EditPasswordSuccessfulCopyWith(EditPasswordSuccessful value, $Res Function(EditPasswordSuccessful) then) =
      _$EditPasswordSuccessfulCopyWithImpl<$Res>;
  @override
  $Res call({String pendingId});
}

/// @nodoc
class _$EditPasswordSuccessfulCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements $EditPasswordSuccessfulCopyWith<$Res> {
  _$EditPasswordSuccessfulCopyWithImpl(EditPasswordSuccessful _value, $Res Function(EditPasswordSuccessful) _then)
      : super(_value, (v) => _then(v as EditPasswordSuccessful));

  @override
  EditPasswordSuccessful get _value => super._value as EditPasswordSuccessful;

  @override
  $Res call({
    Object? pendingId = freezed,
  }) {
    return _then(EditPasswordSuccessful(
      pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@Implements<ActionDone>()
class _$EditPasswordSuccessful implements EditPasswordSuccessful {
  const _$EditPasswordSuccessful([this.pendingId = _kEditPasswordPendingId]);

  @JsonKey()
  @override
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.successful(pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditPasswordSuccessful &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  $EditPasswordSuccessfulCopyWith<EditPasswordSuccessful> get copyWith =>
      _$EditPasswordSuccessfulCopyWithImpl<EditPasswordSuccessful>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return successful(pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return successful?.call(pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return successful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return successful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(this);
    }
    return orElse();
  }
}

abstract class EditPasswordSuccessful implements EditPassword, ActionDone {
  const factory EditPasswordSuccessful([String pendingId]) = _$EditPasswordSuccessful;

  @override
  String get pendingId;
  @override
  @JsonKey(ignore: true)
  $EditPasswordSuccessfulCopyWith<EditPasswordSuccessful> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordErrorCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory $EditPasswordErrorCopyWith(EditPasswordError value, $Res Function(EditPasswordError) then) =
      _$EditPasswordErrorCopyWithImpl<$Res>;
  @override
  $Res call({Object error, StackTrace stackTrace, String pendingId});
}

/// @nodoc
class _$EditPasswordErrorCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements $EditPasswordErrorCopyWith<$Res> {
  _$EditPasswordErrorCopyWithImpl(EditPasswordError _value, $Res Function(EditPasswordError) _then)
      : super(_value, (v) => _then(v as EditPasswordError));

  @override
  EditPasswordError get _value => super._value as EditPasswordError;

  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? pendingId = freezed,
  }) {
    return _then(EditPasswordError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Object,
      stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@Implements<ActionDone>()
@Implements<ErrorAction>()
class _$EditPasswordError implements EditPasswordError {
  const _$EditPasswordError(this.error, this.stackTrace, [this.pendingId = _kEditPasswordPendingId]);

  @override
  final Object error;
  @override
  final StackTrace stackTrace;
  @JsonKey()
  @override
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.error(error: $error, stackTrace: $stackTrace, pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditPasswordError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality().equals(other.stackTrace, stackTrace) &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(error),
      const DeepCollectionEquality().hash(stackTrace), const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  $EditPasswordErrorCopyWith<EditPasswordError> get copyWith =>
      _$EditPasswordErrorCopyWithImpl<EditPasswordError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return error(this.error, stackTrace, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return error?.call(this.error, stackTrace, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, stackTrace, pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class EditPasswordError implements EditPassword, ActionDone, ErrorAction {
  const factory EditPasswordError(Object error, StackTrace stackTrace, [String pendingId]) = _$EditPasswordError;

  Object get error;
  StackTrace get stackTrace;
  @override
  String get pendingId;
  @override
  @JsonKey(ignore: true)
  $EditPasswordErrorCopyWith<EditPasswordError> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$SetScannedCodeTearOff {
  const _$SetScannedCodeTearOff();

  SetScannedCode$ call(Code code) {
    return SetScannedCode$(
      code,
    );
  }
}

/// @nodoc
const $SetScannedCode = _$SetScannedCodeTearOff();

/// @nodoc
mixin _$SetScannedCode {
  Code get code => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetScannedCodeCopyWith<SetScannedCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetScannedCodeCopyWith<$Res> {
  factory $SetScannedCodeCopyWith(SetScannedCode value, $Res Function(SetScannedCode) then) =
      _$SetScannedCodeCopyWithImpl<$Res>;
  $Res call({Code code});

  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$SetScannedCodeCopyWithImpl<$Res> implements $SetScannedCodeCopyWith<$Res> {
  _$SetScannedCodeCopyWithImpl(this._value, this._then);

  final SetScannedCode _value;
  // ignore: unused_field
  final $Res Function(SetScannedCode) _then;

  @override
  $Res call({
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
    ));
  }

  @override
  $CodeCopyWith<$Res> get code {
    return $CodeCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

/// @nodoc
abstract class $SetScannedCode$CopyWith<$Res> implements $SetScannedCodeCopyWith<$Res> {
  factory $SetScannedCode$CopyWith(SetScannedCode$ value, $Res Function(SetScannedCode$) then) =
      _$SetScannedCode$CopyWithImpl<$Res>;
  @override
  $Res call({Code code});

  @override
  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$SetScannedCode$CopyWithImpl<$Res> extends _$SetScannedCodeCopyWithImpl<$Res>
    implements $SetScannedCode$CopyWith<$Res> {
  _$SetScannedCode$CopyWithImpl(SetScannedCode$ _value, $Res Function(SetScannedCode$) _then)
      : super(_value, (v) => _then(v as SetScannedCode$));

  @override
  SetScannedCode$ get _value => super._value as SetScannedCode$;

  @override
  $Res call({
    Object? code = freezed,
  }) {
    return _then(SetScannedCode$(
      code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
    ));
  }
}

/// @nodoc

class _$SetScannedCode$ implements SetScannedCode$ {
  const _$SetScannedCode$(this.code);

  @override
  final Code code;

  @override
  String toString() {
    return 'SetScannedCode(code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetScannedCode$ &&
            const DeepCollectionEquality().equals(other.code, code));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(code));

  @JsonKey(ignore: true)
  @override
  $SetScannedCode$CopyWith<SetScannedCode$> get copyWith =>
      _$SetScannedCode$CopyWithImpl<SetScannedCode$>(this, _$identity);
}

abstract class SetScannedCode$ implements SetScannedCode {
  const factory SetScannedCode$(Code code) = _$SetScannedCode$;

  @override
  Code get code;
  @override
  @JsonKey(ignore: true)
  $SetScannedCode$CopyWith<SetScannedCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$UpdateAccessTimeTearOff {
  const _$UpdateAccessTimeTearOff();

  UpdateAccessTime$ call(String id) {
    return UpdateAccessTime$(
      id,
    );
  }
}

/// @nodoc
const $UpdateAccessTime = _$UpdateAccessTimeTearOff();

/// @nodoc
mixin _$UpdateAccessTime {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UpdateAccessTimeCopyWith<UpdateAccessTime> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateAccessTimeCopyWith<$Res> {
  factory $UpdateAccessTimeCopyWith(UpdateAccessTime value, $Res Function(UpdateAccessTime) then) =
      _$UpdateAccessTimeCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$UpdateAccessTimeCopyWithImpl<$Res> implements $UpdateAccessTimeCopyWith<$Res> {
  _$UpdateAccessTimeCopyWithImpl(this._value, this._then);

  final UpdateAccessTime _value;
  // ignore: unused_field
  final $Res Function(UpdateAccessTime) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $UpdateAccessTime$CopyWith<$Res> implements $UpdateAccessTimeCopyWith<$Res> {
  factory $UpdateAccessTime$CopyWith(UpdateAccessTime$ value, $Res Function(UpdateAccessTime$) then) =
      _$UpdateAccessTime$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class _$UpdateAccessTime$CopyWithImpl<$Res> extends _$UpdateAccessTimeCopyWithImpl<$Res>
    implements $UpdateAccessTime$CopyWith<$Res> {
  _$UpdateAccessTime$CopyWithImpl(UpdateAccessTime$ _value, $Res Function(UpdateAccessTime$) _then)
      : super(_value, (v) => _then(v as UpdateAccessTime$));

  @override
  UpdateAccessTime$ get _value => super._value as UpdateAccessTime$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(UpdateAccessTime$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateAccessTime$ implements UpdateAccessTime$ {
  const _$UpdateAccessTime$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'UpdateAccessTime(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is UpdateAccessTime$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  $UpdateAccessTime$CopyWith<UpdateAccessTime$> get copyWith =>
      _$UpdateAccessTime$CopyWithImpl<UpdateAccessTime$>(this, _$identity);
}

abstract class UpdateAccessTime$ implements UpdateAccessTime {
  const factory UpdateAccessTime$(String id) = _$UpdateAccessTime$;

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  $UpdateAccessTime$CopyWith<UpdateAccessTime$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$GeneratePasswordTearOff {
  const _$GeneratePasswordTearOff();

  GeneratePasswordStart call() {
    return const GeneratePasswordStart();
  }

  GeneratePasswordSuccessful successful(String password) {
    return GeneratePasswordSuccessful(
      password,
    );
  }

  GeneratePasswordError error(Object error, StackTrace stackTrace) {
    return GeneratePasswordError(
      error,
      stackTrace,
    );
  }
}

/// @nodoc
const $GeneratePassword = _$GeneratePasswordTearOff();

/// @nodoc
mixin _$GeneratePassword {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String password) successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value) $default, {
    required TResult Function(GeneratePasswordSuccessful value) successful,
    required TResult Function(GeneratePasswordError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratePasswordCopyWith<$Res> {
  factory $GeneratePasswordCopyWith(GeneratePassword value, $Res Function(GeneratePassword) then) =
      _$GeneratePasswordCopyWithImpl<$Res>;
}

/// @nodoc
class _$GeneratePasswordCopyWithImpl<$Res> implements $GeneratePasswordCopyWith<$Res> {
  _$GeneratePasswordCopyWithImpl(this._value, this._then);

  final GeneratePassword _value;
  // ignore: unused_field
  final $Res Function(GeneratePassword) _then;
}

/// @nodoc
abstract class $GeneratePasswordStartCopyWith<$Res> {
  factory $GeneratePasswordStartCopyWith(GeneratePasswordStart value, $Res Function(GeneratePasswordStart) then) =
      _$GeneratePasswordStartCopyWithImpl<$Res>;
}

/// @nodoc
class _$GeneratePasswordStartCopyWithImpl<$Res> extends _$GeneratePasswordCopyWithImpl<$Res>
    implements $GeneratePasswordStartCopyWith<$Res> {
  _$GeneratePasswordStartCopyWithImpl(GeneratePasswordStart _value, $Res Function(GeneratePasswordStart) _then)
      : super(_value, (v) => _then(v as GeneratePasswordStart));

  @override
  GeneratePasswordStart get _value => super._value as GeneratePasswordStart;
}

/// @nodoc

class _$GeneratePasswordStart implements GeneratePasswordStart {
  const _$GeneratePasswordStart();

  @override
  String toString() {
    return 'GeneratePassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is GeneratePasswordStart);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String password) successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) {
    return $default();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value) $default, {
    required TResult Function(GeneratePasswordSuccessful value) successful,
    required TResult Function(GeneratePasswordError value) error,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class GeneratePasswordStart implements GeneratePassword {
  const factory GeneratePasswordStart() = _$GeneratePasswordStart;
}

/// @nodoc
abstract class $GeneratePasswordSuccessfulCopyWith<$Res> {
  factory $GeneratePasswordSuccessfulCopyWith(
          GeneratePasswordSuccessful value, $Res Function(GeneratePasswordSuccessful) then) =
      _$GeneratePasswordSuccessfulCopyWithImpl<$Res>;
  $Res call({String password});
}

/// @nodoc
class _$GeneratePasswordSuccessfulCopyWithImpl<$Res> extends _$GeneratePasswordCopyWithImpl<$Res>
    implements $GeneratePasswordSuccessfulCopyWith<$Res> {
  _$GeneratePasswordSuccessfulCopyWithImpl(
      GeneratePasswordSuccessful _value, $Res Function(GeneratePasswordSuccessful) _then)
      : super(_value, (v) => _then(v as GeneratePasswordSuccessful));

  @override
  GeneratePasswordSuccessful get _value => super._value as GeneratePasswordSuccessful;

  @override
  $Res call({
    Object? password = freezed,
  }) {
    return _then(GeneratePasswordSuccessful(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GeneratePasswordSuccessful implements GeneratePasswordSuccessful {
  const _$GeneratePasswordSuccessful(this.password);

  @override
  final String password;

  @override
  String toString() {
    return 'GeneratePassword.successful(password: $password)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GeneratePasswordSuccessful &&
            const DeepCollectionEquality().equals(other.password, password));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(password));

  @JsonKey(ignore: true)
  @override
  $GeneratePasswordSuccessfulCopyWith<GeneratePasswordSuccessful> get copyWith =>
      _$GeneratePasswordSuccessfulCopyWithImpl<GeneratePasswordSuccessful>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String password) successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) {
    return successful(password);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) {
    return successful?.call(password);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(password);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value) $default, {
    required TResult Function(GeneratePasswordSuccessful value) successful,
    required TResult Function(GeneratePasswordError value) error,
  }) {
    return successful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
  }) {
    return successful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(this);
    }
    return orElse();
  }
}

abstract class GeneratePasswordSuccessful implements GeneratePassword {
  const factory GeneratePasswordSuccessful(String password) = _$GeneratePasswordSuccessful;

  String get password;
  @JsonKey(ignore: true)
  $GeneratePasswordSuccessfulCopyWith<GeneratePasswordSuccessful> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeneratePasswordErrorCopyWith<$Res> {
  factory $GeneratePasswordErrorCopyWith(GeneratePasswordError value, $Res Function(GeneratePasswordError) then) =
      _$GeneratePasswordErrorCopyWithImpl<$Res>;
  $Res call({Object error, StackTrace stackTrace});
}

/// @nodoc
class _$GeneratePasswordErrorCopyWithImpl<$Res> extends _$GeneratePasswordCopyWithImpl<$Res>
    implements $GeneratePasswordErrorCopyWith<$Res> {
  _$GeneratePasswordErrorCopyWithImpl(GeneratePasswordError _value, $Res Function(GeneratePasswordError) _then)
      : super(_value, (v) => _then(v as GeneratePasswordError));

  @override
  GeneratePasswordError get _value => super._value as GeneratePasswordError;

  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(GeneratePasswordError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Object,
      stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

@Implements<ErrorAction>()
class _$GeneratePasswordError implements GeneratePasswordError {
  const _$GeneratePasswordError(this.error, this.stackTrace);

  @override
  final Object error;
  @override
  final StackTrace stackTrace;

  @override
  String toString() {
    return 'GeneratePassword.error(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GeneratePasswordError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality().equals(other.stackTrace, stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), const DeepCollectionEquality().hash(stackTrace));

  @JsonKey(ignore: true)
  @override
  $GeneratePasswordErrorCopyWith<GeneratePasswordError> get copyWith =>
      _$GeneratePasswordErrorCopyWithImpl<GeneratePasswordError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function() $default, {
    required TResult Function(String password) successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) {
    return error(this.error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) {
    return error?.call(this.error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function(String password)? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value) $default, {
    required TResult Function(GeneratePasswordSuccessful value) successful,
    required TResult Function(GeneratePasswordError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(GeneratePasswordStart value)? $default, {
    TResult Function(GeneratePasswordSuccessful value)? successful,
    TResult Function(GeneratePasswordError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class GeneratePasswordError implements GeneratePassword, ErrorAction {
  const factory GeneratePasswordError(Object error, StackTrace stackTrace) = _$GeneratePasswordError;

  Object get error;
  StackTrace get stackTrace;
  @JsonKey(ignore: true)
  $GeneratePasswordErrorCopyWith<GeneratePasswordError> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$ChangePasswordGeneratorLengthTearOff {
  const _$ChangePasswordGeneratorLengthTearOff();

  ChangePasswordGeneratorLength$ call({required int length}) {
    return ChangePasswordGeneratorLength$(
      length: length,
    );
  }
}

/// @nodoc
const $ChangePasswordGeneratorLength = _$ChangePasswordGeneratorLengthTearOff();

/// @nodoc
mixin _$ChangePasswordGeneratorLength {
  int get length => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChangePasswordGeneratorLengthCopyWith<ChangePasswordGeneratorLength> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChangePasswordGeneratorLengthCopyWith<$Res> {
  factory $ChangePasswordGeneratorLengthCopyWith(
          ChangePasswordGeneratorLength value, $Res Function(ChangePasswordGeneratorLength) then) =
      _$ChangePasswordGeneratorLengthCopyWithImpl<$Res>;
  $Res call({int length});
}

/// @nodoc
class _$ChangePasswordGeneratorLengthCopyWithImpl<$Res> implements $ChangePasswordGeneratorLengthCopyWith<$Res> {
  _$ChangePasswordGeneratorLengthCopyWithImpl(this._value, this._then);

  final ChangePasswordGeneratorLength _value;
  // ignore: unused_field
  final $Res Function(ChangePasswordGeneratorLength) _then;

  @override
  $Res call({
    Object? length = freezed,
  }) {
    return _then(_value.copyWith(
      length: length == freezed
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class $ChangePasswordGeneratorLength$CopyWith<$Res> implements $ChangePasswordGeneratorLengthCopyWith<$Res> {
  factory $ChangePasswordGeneratorLength$CopyWith(
          ChangePasswordGeneratorLength$ value, $Res Function(ChangePasswordGeneratorLength$) then) =
      _$ChangePasswordGeneratorLength$CopyWithImpl<$Res>;
  @override
  $Res call({int length});
}

/// @nodoc
class _$ChangePasswordGeneratorLength$CopyWithImpl<$Res> extends _$ChangePasswordGeneratorLengthCopyWithImpl<$Res>
    implements $ChangePasswordGeneratorLength$CopyWith<$Res> {
  _$ChangePasswordGeneratorLength$CopyWithImpl(
      ChangePasswordGeneratorLength$ _value, $Res Function(ChangePasswordGeneratorLength$) _then)
      : super(_value, (v) => _then(v as ChangePasswordGeneratorLength$));

  @override
  ChangePasswordGeneratorLength$ get _value => super._value as ChangePasswordGeneratorLength$;

  @override
  $Res call({
    Object? length = freezed,
  }) {
    return _then(ChangePasswordGeneratorLength$(
      length: length == freezed
          ? _value.length
          : length // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ChangePasswordGeneratorLength$ implements ChangePasswordGeneratorLength$ {
  const _$ChangePasswordGeneratorLength$({required this.length});

  @override
  final int length;

  @override
  String toString() {
    return 'ChangePasswordGeneratorLength(length: $length)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChangePasswordGeneratorLength$ &&
            const DeepCollectionEquality().equals(other.length, length));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(length));

  @JsonKey(ignore: true)
  @override
  $ChangePasswordGeneratorLength$CopyWith<ChangePasswordGeneratorLength$> get copyWith =>
      _$ChangePasswordGeneratorLength$CopyWithImpl<ChangePasswordGeneratorLength$>(this, _$identity);
}

abstract class ChangePasswordGeneratorLength$ implements ChangePasswordGeneratorLength {
  const factory ChangePasswordGeneratorLength$({required int length}) = _$ChangePasswordGeneratorLength$;

  @override
  int get length;
  @override
  @JsonKey(ignore: true)
  $ChangePasswordGeneratorLength$CopyWith<ChangePasswordGeneratorLength$> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ChangePasswordGeneratorCharacterPoolTearOff {
  const _$ChangePasswordGeneratorCharacterPoolTearOff();

  ChangePasswordGeneratorCharacterPool$ call({required Set<CharacterPool> characterPool}) {
    return ChangePasswordGeneratorCharacterPool$(
      characterPool: characterPool,
    );
  }
}

/// @nodoc
const $ChangePasswordGeneratorCharacterPool = _$ChangePasswordGeneratorCharacterPoolTearOff();

/// @nodoc
mixin _$ChangePasswordGeneratorCharacterPool {
  Set<CharacterPool> get characterPool => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChangePasswordGeneratorCharacterPoolCopyWith<ChangePasswordGeneratorCharacterPool> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChangePasswordGeneratorCharacterPoolCopyWith<$Res> {
  factory $ChangePasswordGeneratorCharacterPoolCopyWith(
          ChangePasswordGeneratorCharacterPool value, $Res Function(ChangePasswordGeneratorCharacterPool) then) =
      _$ChangePasswordGeneratorCharacterPoolCopyWithImpl<$Res>;
  $Res call({Set<CharacterPool> characterPool});
}

/// @nodoc
class _$ChangePasswordGeneratorCharacterPoolCopyWithImpl<$Res>
    implements $ChangePasswordGeneratorCharacterPoolCopyWith<$Res> {
  _$ChangePasswordGeneratorCharacterPoolCopyWithImpl(this._value, this._then);

  final ChangePasswordGeneratorCharacterPool _value;
  // ignore: unused_field
  final $Res Function(ChangePasswordGeneratorCharacterPool) _then;

  @override
  $Res call({
    Object? characterPool = freezed,
  }) {
    return _then(_value.copyWith(
      characterPool: characterPool == freezed
          ? _value.characterPool
          : characterPool // ignore: cast_nullable_to_non_nullable
              as Set<CharacterPool>,
    ));
  }
}

/// @nodoc
abstract class $ChangePasswordGeneratorCharacterPool$CopyWith<$Res>
    implements $ChangePasswordGeneratorCharacterPoolCopyWith<$Res> {
  factory $ChangePasswordGeneratorCharacterPool$CopyWith(
          ChangePasswordGeneratorCharacterPool$ value, $Res Function(ChangePasswordGeneratorCharacterPool$) then) =
      _$ChangePasswordGeneratorCharacterPool$CopyWithImpl<$Res>;
  @override
  $Res call({Set<CharacterPool> characterPool});
}

/// @nodoc
class _$ChangePasswordGeneratorCharacterPool$CopyWithImpl<$Res>
    extends _$ChangePasswordGeneratorCharacterPoolCopyWithImpl<$Res>
    implements $ChangePasswordGeneratorCharacterPool$CopyWith<$Res> {
  _$ChangePasswordGeneratorCharacterPool$CopyWithImpl(
      ChangePasswordGeneratorCharacterPool$ _value, $Res Function(ChangePasswordGeneratorCharacterPool$) _then)
      : super(_value, (v) => _then(v as ChangePasswordGeneratorCharacterPool$));

  @override
  ChangePasswordGeneratorCharacterPool$ get _value => super._value as ChangePasswordGeneratorCharacterPool$;

  @override
  $Res call({
    Object? characterPool = freezed,
  }) {
    return _then(ChangePasswordGeneratorCharacterPool$(
      characterPool: characterPool == freezed
          ? _value.characterPool
          : characterPool // ignore: cast_nullable_to_non_nullable
              as Set<CharacterPool>,
    ));
  }
}

/// @nodoc

class _$ChangePasswordGeneratorCharacterPool$ implements ChangePasswordGeneratorCharacterPool$ {
  const _$ChangePasswordGeneratorCharacterPool$({required this.characterPool});

  @override
  final Set<CharacterPool> characterPool;

  @override
  String toString() {
    return 'ChangePasswordGeneratorCharacterPool(characterPool: $characterPool)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ChangePasswordGeneratorCharacterPool$ &&
            const DeepCollectionEquality().equals(other.characterPool, characterPool));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(characterPool));

  @JsonKey(ignore: true)
  @override
  $ChangePasswordGeneratorCharacterPool$CopyWith<ChangePasswordGeneratorCharacterPool$> get copyWith =>
      _$ChangePasswordGeneratorCharacterPool$CopyWithImpl<ChangePasswordGeneratorCharacterPool$>(this, _$identity);
}

abstract class ChangePasswordGeneratorCharacterPool$ implements ChangePasswordGeneratorCharacterPool {
  const factory ChangePasswordGeneratorCharacterPool$({required Set<CharacterPool> characterPool}) =
      _$ChangePasswordGeneratorCharacterPool$;

  @override
  Set<CharacterPool> get characterPool;
  @override
  @JsonKey(ignore: true)
  $ChangePasswordGeneratorCharacterPool$CopyWith<ChangePasswordGeneratorCharacterPool$> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$SetWalletPrivateKeyTearOff {
  const _$SetWalletPrivateKeyTearOff();

  SetWalletPrivateKey$ call(String walletPrivateKey) {
    return SetWalletPrivateKey$(
      walletPrivateKey,
    );
  }
}

/// @nodoc
const $SetWalletPrivateKey = _$SetWalletPrivateKeyTearOff();

/// @nodoc
mixin _$SetWalletPrivateKey {
  String get walletPrivateKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetWalletPrivateKeyCopyWith<SetWalletPrivateKey> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetWalletPrivateKeyCopyWith<$Res> {
  factory $SetWalletPrivateKeyCopyWith(SetWalletPrivateKey value, $Res Function(SetWalletPrivateKey) then) =
      _$SetWalletPrivateKeyCopyWithImpl<$Res>;
  $Res call({String walletPrivateKey});
}

/// @nodoc
class _$SetWalletPrivateKeyCopyWithImpl<$Res> implements $SetWalletPrivateKeyCopyWith<$Res> {
  _$SetWalletPrivateKeyCopyWithImpl(this._value, this._then);

  final SetWalletPrivateKey _value;
  // ignore: unused_field
  final $Res Function(SetWalletPrivateKey) _then;

  @override
  $Res call({
    Object? walletPrivateKey = freezed,
  }) {
    return _then(_value.copyWith(
      walletPrivateKey: walletPrivateKey == freezed
          ? _value.walletPrivateKey
          : walletPrivateKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $SetWalletPrivateKey$CopyWith<$Res> implements $SetWalletPrivateKeyCopyWith<$Res> {
  factory $SetWalletPrivateKey$CopyWith(SetWalletPrivateKey$ value, $Res Function(SetWalletPrivateKey$) then) =
      _$SetWalletPrivateKey$CopyWithImpl<$Res>;
  @override
  $Res call({String walletPrivateKey});
}

/// @nodoc
class _$SetWalletPrivateKey$CopyWithImpl<$Res> extends _$SetWalletPrivateKeyCopyWithImpl<$Res>
    implements $SetWalletPrivateKey$CopyWith<$Res> {
  _$SetWalletPrivateKey$CopyWithImpl(SetWalletPrivateKey$ _value, $Res Function(SetWalletPrivateKey$) _then)
      : super(_value, (v) => _then(v as SetWalletPrivateKey$));

  @override
  SetWalletPrivateKey$ get _value => super._value as SetWalletPrivateKey$;

  @override
  $Res call({
    Object? walletPrivateKey = freezed,
  }) {
    return _then(SetWalletPrivateKey$(
      walletPrivateKey == freezed
          ? _value.walletPrivateKey
          : walletPrivateKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SetWalletPrivateKey$ implements SetWalletPrivateKey$ {
  const _$SetWalletPrivateKey$(this.walletPrivateKey);

  @override
  final String walletPrivateKey;

  @override
  String toString() {
    return 'SetWalletPrivateKey(walletPrivateKey: $walletPrivateKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetWalletPrivateKey$ &&
            const DeepCollectionEquality().equals(other.walletPrivateKey, walletPrivateKey));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(walletPrivateKey));

  @JsonKey(ignore: true)
  @override
  $SetWalletPrivateKey$CopyWith<SetWalletPrivateKey$> get copyWith =>
      _$SetWalletPrivateKey$CopyWithImpl<SetWalletPrivateKey$>(this, _$identity);
}

abstract class SetWalletPrivateKey$ implements SetWalletPrivateKey {
  const factory SetWalletPrivateKey$(String walletPrivateKey) = _$SetWalletPrivateKey$;

  @override
  String get walletPrivateKey;
  @override
  @JsonKey(ignore: true)
  $SetWalletPrivateKey$CopyWith<SetWalletPrivateKey$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$SetBundleTearOff {
  const _$SetBundleTearOff();

  SetBundle$ call(Bundle bundle) {
    return SetBundle$(
      bundle,
    );
  }
}

/// @nodoc
const $SetBundle = _$SetBundleTearOff();

/// @nodoc
mixin _$SetBundle {
  Bundle get bundle => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetBundleCopyWith<SetBundle> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetBundleCopyWith<$Res> {
  factory $SetBundleCopyWith(SetBundle value, $Res Function(SetBundle) then) = _$SetBundleCopyWithImpl<$Res>;
  $Res call({Bundle bundle});

  $BundleCopyWith<$Res> get bundle;
}

/// @nodoc
class _$SetBundleCopyWithImpl<$Res> implements $SetBundleCopyWith<$Res> {
  _$SetBundleCopyWithImpl(this._value, this._then);

  final SetBundle _value;
  // ignore: unused_field
  final $Res Function(SetBundle) _then;

  @override
  $Res call({
    Object? bundle = freezed,
  }) {
    return _then(_value.copyWith(
      bundle: bundle == freezed
          ? _value.bundle
          : bundle // ignore: cast_nullable_to_non_nullable
              as Bundle,
    ));
  }

  @override
  $BundleCopyWith<$Res> get bundle {
    return $BundleCopyWith<$Res>(_value.bundle, (value) {
      return _then(_value.copyWith(bundle: value));
    });
  }
}

/// @nodoc
abstract class $SetBundle$CopyWith<$Res> implements $SetBundleCopyWith<$Res> {
  factory $SetBundle$CopyWith(SetBundle$ value, $Res Function(SetBundle$) then) = _$SetBundle$CopyWithImpl<$Res>;
  @override
  $Res call({Bundle bundle});

  @override
  $BundleCopyWith<$Res> get bundle;
}

/// @nodoc
class _$SetBundle$CopyWithImpl<$Res> extends _$SetBundleCopyWithImpl<$Res> implements $SetBundle$CopyWith<$Res> {
  _$SetBundle$CopyWithImpl(SetBundle$ _value, $Res Function(SetBundle$) _then)
      : super(_value, (v) => _then(v as SetBundle$));

  @override
  SetBundle$ get _value => super._value as SetBundle$;

  @override
  $Res call({
    Object? bundle = freezed,
  }) {
    return _then(SetBundle$(
      bundle == freezed
          ? _value.bundle
          : bundle // ignore: cast_nullable_to_non_nullable
              as Bundle,
    ));
  }
}

/// @nodoc

class _$SetBundle$ implements SetBundle$ {
  const _$SetBundle$(this.bundle);

  @override
  final Bundle bundle;

  @override
  String toString() {
    return 'SetBundle(bundle: $bundle)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetBundle$ &&
            const DeepCollectionEquality().equals(other.bundle, bundle));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(bundle));

  @JsonKey(ignore: true)
  @override
  $SetBundle$CopyWith<SetBundle$> get copyWith => _$SetBundle$CopyWithImpl<SetBundle$>(this, _$identity);
}

abstract class SetBundle$ implements SetBundle {
  const factory SetBundle$(Bundle bundle) = _$SetBundle$;

  @override
  Bundle get bundle;
  @override
  @JsonKey(ignore: true)
  $SetBundle$CopyWith<SetBundle$> get copyWith => throw _privateConstructorUsedError;
}
