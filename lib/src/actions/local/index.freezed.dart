// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'index.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$CreateNewPasswordTearOff {
  const _$CreateNewPasswordTearOff();

  CreateNewPassword$ call(Password password, String masterKey) {
    return CreateNewPassword$(
      password,
      masterKey,
    );
  }
}

/// @nodoc
const $CreateNewPassword = _$CreateNewPasswordTearOff();

/// @nodoc
mixin _$CreateNewPassword {
  Password get password => throw _privateConstructorUsedError;
  String get masterKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateNewPasswordCopyWith<CreateNewPassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewPasswordCopyWith<$Res> {
  factory $CreateNewPasswordCopyWith(CreateNewPassword value, $Res Function(CreateNewPassword) then) =
      _$CreateNewPasswordCopyWithImpl<$Res>;
  $Res call({Password password, String masterKey});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$CreateNewPasswordCopyWithImpl<$Res> implements $CreateNewPasswordCopyWith<$Res> {
  _$CreateNewPasswordCopyWithImpl(this._value, this._then);

  final CreateNewPassword _value;
  // ignore: unused_field
  final $Res Function(CreateNewPassword) _then;

  @override
  $Res call({
    Object? password = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_value.copyWith(
      password: password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc
abstract class $CreateNewPassword$CopyWith<$Res> implements $CreateNewPasswordCopyWith<$Res> {
  factory $CreateNewPassword$CopyWith(CreateNewPassword$ value, $Res Function(CreateNewPassword$) then) =
      _$CreateNewPassword$CopyWithImpl<$Res>;
  @override
  $Res call({Password password, String masterKey});

  @override
  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$CreateNewPassword$CopyWithImpl<$Res> extends _$CreateNewPasswordCopyWithImpl<$Res>
    implements $CreateNewPassword$CopyWith<$Res> {
  _$CreateNewPassword$CopyWithImpl(CreateNewPassword$ _value, $Res Function(CreateNewPassword$) _then)
      : super(_value, (v) => _then(v as CreateNewPassword$));

  @override
  CreateNewPassword$ get _value => super._value as CreateNewPassword$;

  @override
  $Res call({
    Object? password = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(CreateNewPassword$(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateNewPassword$ implements CreateNewPassword$ {
  const _$CreateNewPassword$(this.password, this.masterKey);

  @override
  final Password password;
  @override
  final String masterKey;

  @override
  String toString() {
    return 'CreateNewPassword(password: $password, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateNewPassword$ &&
            const DeepCollectionEquality().equals(other.password, password) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(password), const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  $CreateNewPassword$CopyWith<CreateNewPassword$> get copyWith =>
      _$CreateNewPassword$CopyWithImpl<CreateNewPassword$>(this, _$identity);
}

abstract class CreateNewPassword$ implements CreateNewPassword {
  const factory CreateNewPassword$(Password password, String masterKey) = _$CreateNewPassword$;

  @override
  Password get password;
  @override
  String get masterKey;
  @override
  @JsonKey(ignore: true)
  $CreateNewPassword$CopyWith<CreateNewPassword$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$CreateNewCodeTearOff {
  const _$CreateNewCodeTearOff();

  CreateNewCode$ call(Code code, String masterKey) {
    return CreateNewCode$(
      code,
      masterKey,
    );
  }
}

/// @nodoc
const $CreateNewCode = _$CreateNewCodeTearOff();

/// @nodoc
mixin _$CreateNewCode {
  Code get code => throw _privateConstructorUsedError;
  String get masterKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateNewCodeCopyWith<CreateNewCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewCodeCopyWith<$Res> {
  factory $CreateNewCodeCopyWith(CreateNewCode value, $Res Function(CreateNewCode) then) =
      _$CreateNewCodeCopyWithImpl<$Res>;
  $Res call({Code code, String masterKey});

  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$CreateNewCodeCopyWithImpl<$Res> implements $CreateNewCodeCopyWith<$Res> {
  _$CreateNewCodeCopyWithImpl(this._value, this._then);

  final CreateNewCode _value;
  // ignore: unused_field
  final $Res Function(CreateNewCode) _then;

  @override
  $Res call({
    Object? code = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_value.copyWith(
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $CodeCopyWith<$Res> get code {
    return $CodeCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

/// @nodoc
abstract class $CreateNewCode$CopyWith<$Res> implements $CreateNewCodeCopyWith<$Res> {
  factory $CreateNewCode$CopyWith(CreateNewCode$ value, $Res Function(CreateNewCode$) then) =
      _$CreateNewCode$CopyWithImpl<$Res>;
  @override
  $Res call({Code code, String masterKey});

  @override
  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$CreateNewCode$CopyWithImpl<$Res> extends _$CreateNewCodeCopyWithImpl<$Res>
    implements $CreateNewCode$CopyWith<$Res> {
  _$CreateNewCode$CopyWithImpl(CreateNewCode$ _value, $Res Function(CreateNewCode$) _then)
      : super(_value, (v) => _then(v as CreateNewCode$));

  @override
  CreateNewCode$ get _value => super._value as CreateNewCode$;

  @override
  $Res call({
    Object? code = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(CreateNewCode$(
      code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateNewCode$ implements CreateNewCode$ {
  const _$CreateNewCode$(this.code, this.masterKey);

  @override
  final Code code;
  @override
  final String masterKey;

  @override
  String toString() {
    return 'CreateNewCode(code: $code, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is CreateNewCode$ &&
            const DeepCollectionEquality().equals(other.code, code) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(code), const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  $CreateNewCode$CopyWith<CreateNewCode$> get copyWith =>
      _$CreateNewCode$CopyWithImpl<CreateNewCode$>(this, _$identity);
}

abstract class CreateNewCode$ implements CreateNewCode {
  const factory CreateNewCode$(Code code, String masterKey) = _$CreateNewCode$;

  @override
  Code get code;
  @override
  String get masterKey;
  @override
  @JsonKey(ignore: true)
  $CreateNewCode$CopyWith<CreateNewCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$DeleteCodeTearOff {
  const _$DeleteCodeTearOff();

  DeleteCode$ call(String id) {
    return DeleteCode$(
      id,
    );
  }
}

/// @nodoc
const $DeleteCode = _$DeleteCodeTearOff();

/// @nodoc
mixin _$DeleteCode {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeleteCodeCopyWith<DeleteCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteCodeCopyWith<$Res> {
  factory $DeleteCodeCopyWith(DeleteCode value, $Res Function(DeleteCode) then) = _$DeleteCodeCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$DeleteCodeCopyWithImpl<$Res> implements $DeleteCodeCopyWith<$Res> {
  _$DeleteCodeCopyWithImpl(this._value, this._then);

  final DeleteCode _value;
  // ignore: unused_field
  final $Res Function(DeleteCode) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $DeleteCode$CopyWith<$Res> implements $DeleteCodeCopyWith<$Res> {
  factory $DeleteCode$CopyWith(DeleteCode$ value, $Res Function(DeleteCode$) then) = _$DeleteCode$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class _$DeleteCode$CopyWithImpl<$Res> extends _$DeleteCodeCopyWithImpl<$Res> implements $DeleteCode$CopyWith<$Res> {
  _$DeleteCode$CopyWithImpl(DeleteCode$ _value, $Res Function(DeleteCode$) _then)
      : super(_value, (v) => _then(v as DeleteCode$));

  @override
  DeleteCode$ get _value => super._value as DeleteCode$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(DeleteCode$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeleteCode$ implements DeleteCode$ {
  const _$DeleteCode$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'DeleteCode(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeleteCode$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  $DeleteCode$CopyWith<DeleteCode$> get copyWith => _$DeleteCode$CopyWithImpl<DeleteCode$>(this, _$identity);
}

abstract class DeleteCode$ implements DeleteCode {
  const factory DeleteCode$(String id) = _$DeleteCode$;

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  $DeleteCode$CopyWith<DeleteCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$DeletePasswordTearOff {
  const _$DeletePasswordTearOff();

  DeletePassword$ call(String id) {
    return DeletePassword$(
      id,
    );
  }
}

/// @nodoc
const $DeletePassword = _$DeletePasswordTearOff();

/// @nodoc
mixin _$DeletePassword {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeletePasswordCopyWith<DeletePassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeletePasswordCopyWith<$Res> {
  factory $DeletePasswordCopyWith(DeletePassword value, $Res Function(DeletePassword) then) =
      _$DeletePasswordCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$DeletePasswordCopyWithImpl<$Res> implements $DeletePasswordCopyWith<$Res> {
  _$DeletePasswordCopyWithImpl(this._value, this._then);

  final DeletePassword _value;
  // ignore: unused_field
  final $Res Function(DeletePassword) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $DeletePassword$CopyWith<$Res> implements $DeletePasswordCopyWith<$Res> {
  factory $DeletePassword$CopyWith(DeletePassword$ value, $Res Function(DeletePassword$) then) =
      _$DeletePassword$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class _$DeletePassword$CopyWithImpl<$Res> extends _$DeletePasswordCopyWithImpl<$Res>
    implements $DeletePassword$CopyWith<$Res> {
  _$DeletePassword$CopyWithImpl(DeletePassword$ _value, $Res Function(DeletePassword$) _then)
      : super(_value, (v) => _then(v as DeletePassword$));

  @override
  DeletePassword$ get _value => super._value as DeletePassword$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(DeletePassword$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeletePassword$ implements DeletePassword$ {
  const _$DeletePassword$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'DeletePassword(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeletePassword$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  $DeletePassword$CopyWith<DeletePassword$> get copyWith =>
      _$DeletePassword$CopyWithImpl<DeletePassword$>(this, _$identity);
}

abstract class DeletePassword$ implements DeletePassword {
  const factory DeletePassword$(String id) = _$DeletePassword$;

  @override
  String get id;
  @override
  @JsonKey(ignore: true)
  $DeletePassword$CopyWith<DeletePassword$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$EditPasswordTearOff {
  const _$EditPasswordTearOff();

  EditPasswordStart start(Password password, {String pendingId = _kEditPasswordPendingId}) {
    return EditPasswordStart(
      password,
      pendingId: pendingId,
    );
  }

  EditPasswordSuccessful successful([String pendingId = _kEditPasswordPendingId]) {
    return EditPasswordSuccessful(
      pendingId,
    );
  }

  EditPasswordError error(Object error, StackTrace stackTrace, [String pendingId = _kEditPasswordPendingId]) {
    return EditPasswordError(
      error,
      stackTrace,
      pendingId,
    );
  }
}

/// @nodoc
const $EditPassword = _$EditPasswordTearOff();

/// @nodoc
mixin _$EditPassword {
  String get pendingId => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EditPasswordCopyWith<EditPassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordCopyWith<$Res> {
  factory $EditPasswordCopyWith(EditPassword value, $Res Function(EditPassword) then) =
      _$EditPasswordCopyWithImpl<$Res>;
  $Res call({String pendingId});
}

/// @nodoc
class _$EditPasswordCopyWithImpl<$Res> implements $EditPasswordCopyWith<$Res> {
  _$EditPasswordCopyWithImpl(this._value, this._then);

  final EditPassword _value;
  // ignore: unused_field
  final $Res Function(EditPassword) _then;

  @override
  $Res call({
    Object? pendingId = freezed,
  }) {
    return _then(_value.copyWith(
      pendingId: pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class $EditPasswordStartCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory $EditPasswordStartCopyWith(EditPasswordStart value, $Res Function(EditPasswordStart) then) =
      _$EditPasswordStartCopyWithImpl<$Res>;
  @override
  $Res call({Password password, String pendingId});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$EditPasswordStartCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements $EditPasswordStartCopyWith<$Res> {
  _$EditPasswordStartCopyWithImpl(EditPasswordStart _value, $Res Function(EditPasswordStart) _then)
      : super(_value, (v) => _then(v as EditPasswordStart));

  @override
  EditPasswordStart get _value => super._value as EditPasswordStart;

  @override
  $Res call({
    Object? password = freezed,
    Object? pendingId = freezed,
  }) {
    return _then(EditPasswordStart(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      pendingId: pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc

@Implements<ActionStart>()
class _$EditPasswordStart implements EditPasswordStart {
  const _$EditPasswordStart(this.password, {this.pendingId = _kEditPasswordPendingId});

  @override
  final Password password;
  @JsonKey()
  @override
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.start(password: $password, pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditPasswordStart &&
            const DeepCollectionEquality().equals(other.password, password) &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(password), const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  $EditPasswordStartCopyWith<EditPasswordStart> get copyWith =>
      _$EditPasswordStartCopyWithImpl<EditPasswordStart>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return start(password, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return start?.call(password, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(password, pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return start(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return start?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(this);
    }
    return orElse();
  }
}

abstract class EditPasswordStart implements EditPassword, ActionStart {
  const factory EditPasswordStart(Password password, {String pendingId}) = _$EditPasswordStart;

  Password get password;
  @override
  String get pendingId;
  @override
  @JsonKey(ignore: true)
  $EditPasswordStartCopyWith<EditPasswordStart> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordSuccessfulCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory $EditPasswordSuccessfulCopyWith(EditPasswordSuccessful value, $Res Function(EditPasswordSuccessful) then) =
      _$EditPasswordSuccessfulCopyWithImpl<$Res>;
  @override
  $Res call({String pendingId});
}

/// @nodoc
class _$EditPasswordSuccessfulCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements $EditPasswordSuccessfulCopyWith<$Res> {
  _$EditPasswordSuccessfulCopyWithImpl(EditPasswordSuccessful _value, $Res Function(EditPasswordSuccessful) _then)
      : super(_value, (v) => _then(v as EditPasswordSuccessful));

  @override
  EditPasswordSuccessful get _value => super._value as EditPasswordSuccessful;

  @override
  $Res call({
    Object? pendingId = freezed,
  }) {
    return _then(EditPasswordSuccessful(
      pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@Implements<ActionDone>()
class _$EditPasswordSuccessful implements EditPasswordSuccessful {
  const _$EditPasswordSuccessful([this.pendingId = _kEditPasswordPendingId]);

  @JsonKey()
  @override
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.successful(pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditPasswordSuccessful &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  $EditPasswordSuccessfulCopyWith<EditPasswordSuccessful> get copyWith =>
      _$EditPasswordSuccessfulCopyWithImpl<EditPasswordSuccessful>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return successful(pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return successful?.call(pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return successful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return successful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(this);
    }
    return orElse();
  }
}

abstract class EditPasswordSuccessful implements EditPassword, ActionDone {
  const factory EditPasswordSuccessful([String pendingId]) = _$EditPasswordSuccessful;

  @override
  String get pendingId;
  @override
  @JsonKey(ignore: true)
  $EditPasswordSuccessfulCopyWith<EditPasswordSuccessful> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordErrorCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory $EditPasswordErrorCopyWith(EditPasswordError value, $Res Function(EditPasswordError) then) =
      _$EditPasswordErrorCopyWithImpl<$Res>;
  @override
  $Res call({Object error, StackTrace stackTrace, String pendingId});
}

/// @nodoc
class _$EditPasswordErrorCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements $EditPasswordErrorCopyWith<$Res> {
  _$EditPasswordErrorCopyWithImpl(EditPasswordError _value, $Res Function(EditPasswordError) _then)
      : super(_value, (v) => _then(v as EditPasswordError));

  @override
  EditPasswordError get _value => super._value as EditPasswordError;

  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? pendingId = freezed,
  }) {
    return _then(EditPasswordError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Object,
      stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@Implements<ActionDone>()
@Implements<ErrorAction>()
class _$EditPasswordError implements EditPasswordError {
  const _$EditPasswordError(this.error, this.stackTrace, [this.pendingId = _kEditPasswordPendingId]);

  @override
  final Object error;
  @override
  final StackTrace stackTrace;
  @JsonKey()
  @override
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.error(error: $error, stackTrace: $stackTrace, pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EditPasswordError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality().equals(other.stackTrace, stackTrace) &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(error),
      const DeepCollectionEquality().hash(stackTrace), const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  $EditPasswordErrorCopyWith<EditPasswordError> get copyWith =>
      _$EditPasswordErrorCopyWithImpl<EditPasswordError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return error(this.error, stackTrace, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return error?.call(this.error, stackTrace, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, stackTrace, pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class EditPasswordError implements EditPassword, ActionDone, ErrorAction {
  const factory EditPasswordError(Object error, StackTrace stackTrace, [String pendingId]) = _$EditPasswordError;

  Object get error;
  StackTrace get stackTrace;
  @override
  String get pendingId;
  @override
  @JsonKey(ignore: true)
  $EditPasswordErrorCopyWith<EditPasswordError> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$SetDetailsPasswordTargetTearOff {
  const _$SetDetailsPasswordTargetTearOff();

  SetDetailsPasswordTargetStart call(Password password, ActionResult onResult) {
    return SetDetailsPasswordTargetStart(
      password,
      onResult,
    );
  }

  SetDetailsPasswordTargetSuccessful successful() {
    return const SetDetailsPasswordTargetSuccessful();
  }

  SetDetailsPasswordTargetError error(Object error, StackTrace stackTrace) {
    return SetDetailsPasswordTargetError(
      error,
      stackTrace,
    );
  }
}

/// @nodoc
const $SetDetailsPasswordTarget = _$SetDetailsPasswordTargetTearOff();

/// @nodoc
mixin _$SetDetailsPasswordTarget {
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult) $default, {
    required TResult Function() successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value) $default, {
    required TResult Function(SetDetailsPasswordTargetSuccessful value) successful,
    required TResult Function(SetDetailsPasswordTargetError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetDetailsPasswordTargetCopyWith<$Res> {
  factory $SetDetailsPasswordTargetCopyWith(
          SetDetailsPasswordTarget value, $Res Function(SetDetailsPasswordTarget) then) =
      _$SetDetailsPasswordTargetCopyWithImpl<$Res>;
}

/// @nodoc
class _$SetDetailsPasswordTargetCopyWithImpl<$Res> implements $SetDetailsPasswordTargetCopyWith<$Res> {
  _$SetDetailsPasswordTargetCopyWithImpl(this._value, this._then);

  final SetDetailsPasswordTarget _value;
  // ignore: unused_field
  final $Res Function(SetDetailsPasswordTarget) _then;
}

/// @nodoc
abstract class $SetDetailsPasswordTargetStartCopyWith<$Res> {
  factory $SetDetailsPasswordTargetStartCopyWith(
          SetDetailsPasswordTargetStart value, $Res Function(SetDetailsPasswordTargetStart) then) =
      _$SetDetailsPasswordTargetStartCopyWithImpl<$Res>;
  $Res call({Password password, ActionResult onResult});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$SetDetailsPasswordTargetStartCopyWithImpl<$Res> extends _$SetDetailsPasswordTargetCopyWithImpl<$Res>
    implements $SetDetailsPasswordTargetStartCopyWith<$Res> {
  _$SetDetailsPasswordTargetStartCopyWithImpl(
      SetDetailsPasswordTargetStart _value, $Res Function(SetDetailsPasswordTargetStart) _then)
      : super(_value, (v) => _then(v as SetDetailsPasswordTargetStart));

  @override
  SetDetailsPasswordTargetStart get _value => super._value as SetDetailsPasswordTargetStart;

  @override
  $Res call({
    Object? password = freezed,
    Object? onResult = freezed,
  }) {
    return _then(SetDetailsPasswordTargetStart(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      onResult == freezed
          ? _value.onResult
          : onResult // ignore: cast_nullable_to_non_nullable
              as ActionResult,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc

class _$SetDetailsPasswordTargetStart implements SetDetailsPasswordTargetStart {
  const _$SetDetailsPasswordTargetStart(this.password, this.onResult);

  @override
  final Password password;
  @override
  final ActionResult onResult;

  @override
  String toString() {
    return 'SetDetailsPasswordTarget(password: $password, onResult: $onResult)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetDetailsPasswordTargetStart &&
            const DeepCollectionEquality().equals(other.password, password) &&
            (identical(other.onResult, onResult) || other.onResult == onResult));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(password), onResult);

  @JsonKey(ignore: true)
  @override
  $SetDetailsPasswordTargetStartCopyWith<SetDetailsPasswordTargetStart> get copyWith =>
      _$SetDetailsPasswordTargetStartCopyWithImpl<SetDetailsPasswordTargetStart>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult) $default, {
    required TResult Function() successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) {
    return $default(password, onResult);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) {
    return $default?.call(password, onResult);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(password, onResult);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value) $default, {
    required TResult Function(SetDetailsPasswordTargetSuccessful value) successful,
    required TResult Function(SetDetailsPasswordTargetError value) error,
  }) {
    return $default(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
  }) {
    return $default?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default(this);
    }
    return orElse();
  }
}

abstract class SetDetailsPasswordTargetStart implements SetDetailsPasswordTarget {
  const factory SetDetailsPasswordTargetStart(Password password, ActionResult onResult) =
      _$SetDetailsPasswordTargetStart;

  Password get password;
  ActionResult get onResult;
  @JsonKey(ignore: true)
  $SetDetailsPasswordTargetStartCopyWith<SetDetailsPasswordTargetStart> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetDetailsPasswordTargetSuccessfulCopyWith<$Res> {
  factory $SetDetailsPasswordTargetSuccessfulCopyWith(
          SetDetailsPasswordTargetSuccessful value, $Res Function(SetDetailsPasswordTargetSuccessful) then) =
      _$SetDetailsPasswordTargetSuccessfulCopyWithImpl<$Res>;
}

/// @nodoc
class _$SetDetailsPasswordTargetSuccessfulCopyWithImpl<$Res> extends _$SetDetailsPasswordTargetCopyWithImpl<$Res>
    implements $SetDetailsPasswordTargetSuccessfulCopyWith<$Res> {
  _$SetDetailsPasswordTargetSuccessfulCopyWithImpl(
      SetDetailsPasswordTargetSuccessful _value, $Res Function(SetDetailsPasswordTargetSuccessful) _then)
      : super(_value, (v) => _then(v as SetDetailsPasswordTargetSuccessful));

  @override
  SetDetailsPasswordTargetSuccessful get _value => super._value as SetDetailsPasswordTargetSuccessful;
}

/// @nodoc

class _$SetDetailsPasswordTargetSuccessful implements SetDetailsPasswordTargetSuccessful {
  const _$SetDetailsPasswordTargetSuccessful();

  @override
  String toString() {
    return 'SetDetailsPasswordTarget.successful()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is SetDetailsPasswordTargetSuccessful);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult) $default, {
    required TResult Function() successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) {
    return successful();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) {
    return successful?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value) $default, {
    required TResult Function(SetDetailsPasswordTargetSuccessful value) successful,
    required TResult Function(SetDetailsPasswordTargetError value) error,
  }) {
    return successful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
  }) {
    return successful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(this);
    }
    return orElse();
  }
}

abstract class SetDetailsPasswordTargetSuccessful implements SetDetailsPasswordTarget {
  const factory SetDetailsPasswordTargetSuccessful() = _$SetDetailsPasswordTargetSuccessful;
}

/// @nodoc
abstract class $SetDetailsPasswordTargetErrorCopyWith<$Res> {
  factory $SetDetailsPasswordTargetErrorCopyWith(
          SetDetailsPasswordTargetError value, $Res Function(SetDetailsPasswordTargetError) then) =
      _$SetDetailsPasswordTargetErrorCopyWithImpl<$Res>;
  $Res call({Object error, StackTrace stackTrace});
}

/// @nodoc
class _$SetDetailsPasswordTargetErrorCopyWithImpl<$Res> extends _$SetDetailsPasswordTargetCopyWithImpl<$Res>
    implements $SetDetailsPasswordTargetErrorCopyWith<$Res> {
  _$SetDetailsPasswordTargetErrorCopyWithImpl(
      SetDetailsPasswordTargetError _value, $Res Function(SetDetailsPasswordTargetError) _then)
      : super(_value, (v) => _then(v as SetDetailsPasswordTargetError));

  @override
  SetDetailsPasswordTargetError get _value => super._value as SetDetailsPasswordTargetError;

  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(SetDetailsPasswordTargetError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Object,
      stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
    ));
  }
}

/// @nodoc

@Implements<ErrorAction>()
class _$SetDetailsPasswordTargetError implements SetDetailsPasswordTargetError {
  const _$SetDetailsPasswordTargetError(this.error, this.stackTrace);

  @override
  final Object error;
  @override
  final StackTrace stackTrace;

  @override
  String toString() {
    return 'SetDetailsPasswordTarget.error(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetDetailsPasswordTargetError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality().equals(other.stackTrace, stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), const DeepCollectionEquality().hash(stackTrace));

  @JsonKey(ignore: true)
  @override
  $SetDetailsPasswordTargetErrorCopyWith<SetDetailsPasswordTargetError> get copyWith =>
      _$SetDetailsPasswordTargetErrorCopyWithImpl<SetDetailsPasswordTargetError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult) $default, {
    required TResult Function() successful,
    required TResult Function(Object error, StackTrace stackTrace) error,
  }) {
    return error(this.error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
  }) {
    return error?.call(this.error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(Password password, ActionResult onResult)? $default, {
    TResult Function()? successful,
    TResult Function(Object error, StackTrace stackTrace)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value) $default, {
    required TResult Function(SetDetailsPasswordTargetSuccessful value) successful,
    required TResult Function(SetDetailsPasswordTargetError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(SetDetailsPasswordTargetStart value)? $default, {
    TResult Function(SetDetailsPasswordTargetSuccessful value)? successful,
    TResult Function(SetDetailsPasswordTargetError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class SetDetailsPasswordTargetError implements SetDetailsPasswordTarget, ErrorAction {
  const factory SetDetailsPasswordTargetError(Object error, StackTrace stackTrace) = _$SetDetailsPasswordTargetError;

  Object get error;
  StackTrace get stackTrace;
  @JsonKey(ignore: true)
  $SetDetailsPasswordTargetErrorCopyWith<SetDetailsPasswordTargetError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$SetScannedCodeTearOff {
  const _$SetScannedCodeTearOff();

  SetScannedCode$ call(Code code) {
    return SetScannedCode$(
      code,
    );
  }
}

/// @nodoc
const $SetScannedCode = _$SetScannedCodeTearOff();

/// @nodoc
mixin _$SetScannedCode {
  Code get code => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetScannedCodeCopyWith<SetScannedCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetScannedCodeCopyWith<$Res> {
  factory $SetScannedCodeCopyWith(SetScannedCode value, $Res Function(SetScannedCode) then) =
      _$SetScannedCodeCopyWithImpl<$Res>;
  $Res call({Code code});

  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$SetScannedCodeCopyWithImpl<$Res> implements $SetScannedCodeCopyWith<$Res> {
  _$SetScannedCodeCopyWithImpl(this._value, this._then);

  final SetScannedCode _value;
  // ignore: unused_field
  final $Res Function(SetScannedCode) _then;

  @override
  $Res call({
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
    ));
  }

  @override
  $CodeCopyWith<$Res> get code {
    return $CodeCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

/// @nodoc
abstract class $SetScannedCode$CopyWith<$Res> implements $SetScannedCodeCopyWith<$Res> {
  factory $SetScannedCode$CopyWith(SetScannedCode$ value, $Res Function(SetScannedCode$) then) =
      _$SetScannedCode$CopyWithImpl<$Res>;
  @override
  $Res call({Code code});

  @override
  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$SetScannedCode$CopyWithImpl<$Res> extends _$SetScannedCodeCopyWithImpl<$Res>
    implements $SetScannedCode$CopyWith<$Res> {
  _$SetScannedCode$CopyWithImpl(SetScannedCode$ _value, $Res Function(SetScannedCode$) _then)
      : super(_value, (v) => _then(v as SetScannedCode$));

  @override
  SetScannedCode$ get _value => super._value as SetScannedCode$;

  @override
  $Res call({
    Object? code = freezed,
  }) {
    return _then(SetScannedCode$(
      code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
    ));
  }
}

/// @nodoc

class _$SetScannedCode$ implements SetScannedCode$ {
  const _$SetScannedCode$(this.code);

  @override
  final Code code;

  @override
  String toString() {
    return 'SetScannedCode(code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SetScannedCode$ &&
            const DeepCollectionEquality().equals(other.code, code));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(code));

  @JsonKey(ignore: true)
  @override
  $SetScannedCode$CopyWith<SetScannedCode$> get copyWith =>
      _$SetScannedCode$CopyWithImpl<SetScannedCode$>(this, _$identity);
}

abstract class SetScannedCode$ implements SetScannedCode {
  const factory SetScannedCode$(Code code) = _$SetScannedCode$;

  @override
  Code get code;
  @override
  @JsonKey(ignore: true)
  $SetScannedCode$CopyWith<SetScannedCode$> get copyWith => throw _privateConstructorUsedError;
}
