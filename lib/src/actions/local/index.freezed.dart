// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'index.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CreateNewPassword {
  Password get password => throw _privateConstructorUsedError;
  String get masterKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateNewPasswordCopyWith<CreateNewPassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewPasswordCopyWith<$Res> {
  factory $CreateNewPasswordCopyWith(CreateNewPassword value, $Res Function(CreateNewPassword) then) =
      _$CreateNewPasswordCopyWithImpl<$Res>;
  $Res call({Password password, String masterKey});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class _$CreateNewPasswordCopyWithImpl<$Res> implements $CreateNewPasswordCopyWith<$Res> {
  _$CreateNewPasswordCopyWithImpl(this._value, this._then);

  final CreateNewPassword _value;
  // ignore: unused_field
  final $Res Function(CreateNewPassword) _then;

  @override
  $Res call({
    Object? password = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_value.copyWith(
      password: password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc
abstract class _$$CreateNewPassword$CopyWith<$Res> implements $CreateNewPasswordCopyWith<$Res> {
  factory _$$CreateNewPassword$CopyWith(_$CreateNewPassword$ value, $Res Function(_$CreateNewPassword$) then) =
      __$$CreateNewPassword$CopyWithImpl<$Res>;
  @override
  $Res call({Password password, String masterKey});

  @override
  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class __$$CreateNewPassword$CopyWithImpl<$Res> extends _$CreateNewPasswordCopyWithImpl<$Res>
    implements _$$CreateNewPassword$CopyWith<$Res> {
  __$$CreateNewPassword$CopyWithImpl(_$CreateNewPassword$ _value, $Res Function(_$CreateNewPassword$) _then)
      : super(_value, (v) => _then(v as _$CreateNewPassword$));

  @override
  _$CreateNewPassword$ get _value => super._value as _$CreateNewPassword$;

  @override
  $Res call({
    Object? password = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_$CreateNewPassword$(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateNewPassword$ implements CreateNewPassword$ {
  const _$CreateNewPassword$(this.password, this.masterKey);

  @override
  final Password password;
  @override
  final String masterKey;

  @override
  String toString() {
    return 'CreateNewPassword(password: $password, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateNewPassword$ &&
            const DeepCollectionEquality().equals(other.password, password) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(password), const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  _$$CreateNewPassword$CopyWith<_$CreateNewPassword$> get copyWith =>
      __$$CreateNewPassword$CopyWithImpl<_$CreateNewPassword$>(this, _$identity);
}

abstract class CreateNewPassword$ implements CreateNewPassword {
  const factory CreateNewPassword$(final Password password, final String masterKey) = _$CreateNewPassword$;

  @override
  Password get password => throw _privateConstructorUsedError;
  @override
  String get masterKey => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$CreateNewPassword$CopyWith<_$CreateNewPassword$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CreateNewCode {
  Code get code => throw _privateConstructorUsedError;
  String get masterKey => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CreateNewCodeCopyWith<CreateNewCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CreateNewCodeCopyWith<$Res> {
  factory $CreateNewCodeCopyWith(CreateNewCode value, $Res Function(CreateNewCode) then) =
      _$CreateNewCodeCopyWithImpl<$Res>;
  $Res call({Code code, String masterKey});

  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$CreateNewCodeCopyWithImpl<$Res> implements $CreateNewCodeCopyWith<$Res> {
  _$CreateNewCodeCopyWithImpl(this._value, this._then);

  final CreateNewCode _value;
  // ignore: unused_field
  final $Res Function(CreateNewCode) _then;

  @override
  $Res call({
    Object? code = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_value.copyWith(
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
      masterKey: masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $CodeCopyWith<$Res> get code {
    return $CodeCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

/// @nodoc
abstract class _$$CreateNewCode$CopyWith<$Res> implements $CreateNewCodeCopyWith<$Res> {
  factory _$$CreateNewCode$CopyWith(_$CreateNewCode$ value, $Res Function(_$CreateNewCode$) then) =
      __$$CreateNewCode$CopyWithImpl<$Res>;
  @override
  $Res call({Code code, String masterKey});

  @override
  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class __$$CreateNewCode$CopyWithImpl<$Res> extends _$CreateNewCodeCopyWithImpl<$Res>
    implements _$$CreateNewCode$CopyWith<$Res> {
  __$$CreateNewCode$CopyWithImpl(_$CreateNewCode$ _value, $Res Function(_$CreateNewCode$) _then)
      : super(_value, (v) => _then(v as _$CreateNewCode$));

  @override
  _$CreateNewCode$ get _value => super._value as _$CreateNewCode$;

  @override
  $Res call({
    Object? code = freezed,
    Object? masterKey = freezed,
  }) {
    return _then(_$CreateNewCode$(
      code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
      masterKey == freezed
          ? _value.masterKey
          : masterKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CreateNewCode$ implements CreateNewCode$ {
  const _$CreateNewCode$(this.code, this.masterKey);

  @override
  final Code code;
  @override
  final String masterKey;

  @override
  String toString() {
    return 'CreateNewCode(code: $code, masterKey: $masterKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CreateNewCode$ &&
            const DeepCollectionEquality().equals(other.code, code) &&
            const DeepCollectionEquality().equals(other.masterKey, masterKey));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(code), const DeepCollectionEquality().hash(masterKey));

  @JsonKey(ignore: true)
  @override
  _$$CreateNewCode$CopyWith<_$CreateNewCode$> get copyWith =>
      __$$CreateNewCode$CopyWithImpl<_$CreateNewCode$>(this, _$identity);
}

abstract class CreateNewCode$ implements CreateNewCode {
  const factory CreateNewCode$(final Code code, final String masterKey) = _$CreateNewCode$;

  @override
  Code get code => throw _privateConstructorUsedError;
  @override
  String get masterKey => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$CreateNewCode$CopyWith<_$CreateNewCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DeleteCode {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeleteCodeCopyWith<DeleteCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeleteCodeCopyWith<$Res> {
  factory $DeleteCodeCopyWith(DeleteCode value, $Res Function(DeleteCode) then) = _$DeleteCodeCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$DeleteCodeCopyWithImpl<$Res> implements $DeleteCodeCopyWith<$Res> {
  _$DeleteCodeCopyWithImpl(this._value, this._then);

  final DeleteCode _value;
  // ignore: unused_field
  final $Res Function(DeleteCode) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$DeleteCode$CopyWith<$Res> implements $DeleteCodeCopyWith<$Res> {
  factory _$$DeleteCode$CopyWith(_$DeleteCode$ value, $Res Function(_$DeleteCode$) then) =
      __$$DeleteCode$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class __$$DeleteCode$CopyWithImpl<$Res> extends _$DeleteCodeCopyWithImpl<$Res> implements _$$DeleteCode$CopyWith<$Res> {
  __$$DeleteCode$CopyWithImpl(_$DeleteCode$ _value, $Res Function(_$DeleteCode$) _then)
      : super(_value, (v) => _then(v as _$DeleteCode$));

  @override
  _$DeleteCode$ get _value => super._value as _$DeleteCode$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$DeleteCode$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeleteCode$ implements DeleteCode$ {
  const _$DeleteCode$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'DeleteCode(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeleteCode$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  _$$DeleteCode$CopyWith<_$DeleteCode$> get copyWith => __$$DeleteCode$CopyWithImpl<_$DeleteCode$>(this, _$identity);
}

abstract class DeleteCode$ implements DeleteCode {
  const factory DeleteCode$(final String id) = _$DeleteCode$;

  @override
  String get id => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$DeleteCode$CopyWith<_$DeleteCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DeletePassword {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DeletePasswordCopyWith<DeletePassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeletePasswordCopyWith<$Res> {
  factory $DeletePasswordCopyWith(DeletePassword value, $Res Function(DeletePassword) then) =
      _$DeletePasswordCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$DeletePasswordCopyWithImpl<$Res> implements $DeletePasswordCopyWith<$Res> {
  _$DeletePasswordCopyWithImpl(this._value, this._then);

  final DeletePassword _value;
  // ignore: unused_field
  final $Res Function(DeletePassword) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$DeletePassword$CopyWith<$Res> implements $DeletePasswordCopyWith<$Res> {
  factory _$$DeletePassword$CopyWith(_$DeletePassword$ value, $Res Function(_$DeletePassword$) then) =
      __$$DeletePassword$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class __$$DeletePassword$CopyWithImpl<$Res> extends _$DeletePasswordCopyWithImpl<$Res>
    implements _$$DeletePassword$CopyWith<$Res> {
  __$$DeletePassword$CopyWithImpl(_$DeletePassword$ _value, $Res Function(_$DeletePassword$) _then)
      : super(_value, (v) => _then(v as _$DeletePassword$));

  @override
  _$DeletePassword$ get _value => super._value as _$DeletePassword$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$DeletePassword$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DeletePassword$ implements DeletePassword$ {
  const _$DeletePassword$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'DeletePassword(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeletePassword$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  _$$DeletePassword$CopyWith<_$DeletePassword$> get copyWith =>
      __$$DeletePassword$CopyWithImpl<_$DeletePassword$>(this, _$identity);
}

abstract class DeletePassword$ implements DeletePassword {
  const factory DeletePassword$(final String id) = _$DeletePassword$;

  @override
  String get id => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$DeletePassword$CopyWith<_$DeletePassword$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EditPassword {
  String get pendingId => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EditPasswordCopyWith<EditPassword> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditPasswordCopyWith<$Res> {
  factory $EditPasswordCopyWith(EditPassword value, $Res Function(EditPassword) then) =
      _$EditPasswordCopyWithImpl<$Res>;
  $Res call({String pendingId});
}

/// @nodoc
class _$EditPasswordCopyWithImpl<$Res> implements $EditPasswordCopyWith<$Res> {
  _$EditPasswordCopyWithImpl(this._value, this._then);

  final EditPassword _value;
  // ignore: unused_field
  final $Res Function(EditPassword) _then;

  @override
  $Res call({
    Object? pendingId = freezed,
  }) {
    return _then(_value.copyWith(
      pendingId: pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$EditPasswordStartCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory _$$EditPasswordStartCopyWith(_$EditPasswordStart value, $Res Function(_$EditPasswordStart) then) =
      __$$EditPasswordStartCopyWithImpl<$Res>;
  @override
  $Res call({Password password, String pendingId});

  $PasswordCopyWith<$Res> get password;
}

/// @nodoc
class __$$EditPasswordStartCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements _$$EditPasswordStartCopyWith<$Res> {
  __$$EditPasswordStartCopyWithImpl(_$EditPasswordStart _value, $Res Function(_$EditPasswordStart) _then)
      : super(_value, (v) => _then(v as _$EditPasswordStart));

  @override
  _$EditPasswordStart get _value => super._value as _$EditPasswordStart;

  @override
  $Res call({
    Object? password = freezed,
    Object? pendingId = freezed,
  }) {
    return _then(_$EditPasswordStart(
      password == freezed
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as Password,
      pendingId: pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $PasswordCopyWith<$Res> get password {
    return $PasswordCopyWith<$Res>(_value.password, (value) {
      return _then(_value.copyWith(password: value));
    });
  }
}

/// @nodoc

class _$EditPasswordStart implements EditPasswordStart {
  const _$EditPasswordStart(this.password, {this.pendingId = _kEditPasswordPendingId});

  @override
  final Password password;
  @override
  @JsonKey()
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.start(password: $password, pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditPasswordStart &&
            const DeepCollectionEquality().equals(other.password, password) &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(password), const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  _$$EditPasswordStartCopyWith<_$EditPasswordStart> get copyWith =>
      __$$EditPasswordStartCopyWithImpl<_$EditPasswordStart>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return start(password, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return start?.call(password, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(password, pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return start(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return start?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (start != null) {
      return start(this);
    }
    return orElse();
  }
}

abstract class EditPasswordStart implements EditPassword, ActionStart {
  const factory EditPasswordStart(final Password password, {final String pendingId}) = _$EditPasswordStart;

  Password get password => throw _privateConstructorUsedError;
  @override
  String get pendingId => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$EditPasswordStartCopyWith<_$EditPasswordStart> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditPasswordSuccessfulCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory _$$EditPasswordSuccessfulCopyWith(
          _$EditPasswordSuccessful value, $Res Function(_$EditPasswordSuccessful) then) =
      __$$EditPasswordSuccessfulCopyWithImpl<$Res>;
  @override
  $Res call({String pendingId});
}

/// @nodoc
class __$$EditPasswordSuccessfulCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements _$$EditPasswordSuccessfulCopyWith<$Res> {
  __$$EditPasswordSuccessfulCopyWithImpl(_$EditPasswordSuccessful _value, $Res Function(_$EditPasswordSuccessful) _then)
      : super(_value, (v) => _then(v as _$EditPasswordSuccessful));

  @override
  _$EditPasswordSuccessful get _value => super._value as _$EditPasswordSuccessful;

  @override
  $Res call({
    Object? pendingId = freezed,
  }) {
    return _then(_$EditPasswordSuccessful(
      pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EditPasswordSuccessful implements EditPasswordSuccessful {
  const _$EditPasswordSuccessful([this.pendingId = _kEditPasswordPendingId]);

  @override
  @JsonKey()
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.successful(pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditPasswordSuccessful &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  _$$EditPasswordSuccessfulCopyWith<_$EditPasswordSuccessful> get copyWith =>
      __$$EditPasswordSuccessfulCopyWithImpl<_$EditPasswordSuccessful>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return successful(pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return successful?.call(pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return successful(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return successful?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (successful != null) {
      return successful(this);
    }
    return orElse();
  }
}

abstract class EditPasswordSuccessful implements EditPassword, ActionDone {
  const factory EditPasswordSuccessful([final String pendingId]) = _$EditPasswordSuccessful;

  @override
  String get pendingId => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$EditPasswordSuccessfulCopyWith<_$EditPasswordSuccessful> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EditPasswordErrorCopyWith<$Res> implements $EditPasswordCopyWith<$Res> {
  factory _$$EditPasswordErrorCopyWith(_$EditPasswordError value, $Res Function(_$EditPasswordError) then) =
      __$$EditPasswordErrorCopyWithImpl<$Res>;
  @override
  $Res call({Object error, StackTrace stackTrace, String pendingId});
}

/// @nodoc
class __$$EditPasswordErrorCopyWithImpl<$Res> extends _$EditPasswordCopyWithImpl<$Res>
    implements _$$EditPasswordErrorCopyWith<$Res> {
  __$$EditPasswordErrorCopyWithImpl(_$EditPasswordError _value, $Res Function(_$EditPasswordError) _then)
      : super(_value, (v) => _then(v as _$EditPasswordError));

  @override
  _$EditPasswordError get _value => super._value as _$EditPasswordError;

  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? pendingId = freezed,
  }) {
    return _then(_$EditPasswordError(
      error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as Object,
      stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace,
      pendingId == freezed
          ? _value.pendingId
          : pendingId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EditPasswordError implements EditPasswordError {
  const _$EditPasswordError(this.error, this.stackTrace, [this.pendingId = _kEditPasswordPendingId]);

  @override
  final Object error;
  @override
  final StackTrace stackTrace;
  @override
  @JsonKey()
  final String pendingId;

  @override
  String toString() {
    return 'EditPassword.error(error: $error, stackTrace: $stackTrace, pendingId: $pendingId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditPasswordError &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality().equals(other.stackTrace, stackTrace) &&
            const DeepCollectionEquality().equals(other.pendingId, pendingId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(error),
      const DeepCollectionEquality().hash(stackTrace), const DeepCollectionEquality().hash(pendingId));

  @JsonKey(ignore: true)
  @override
  _$$EditPasswordErrorCopyWith<_$EditPasswordError> get copyWith =>
      __$$EditPasswordErrorCopyWithImpl<_$EditPasswordError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Password password, String pendingId) start,
    required TResult Function(String pendingId) successful,
    required TResult Function(Object error, StackTrace stackTrace, String pendingId) error,
  }) {
    return error(this.error, stackTrace, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
  }) {
    return error?.call(this.error, stackTrace, pendingId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Password password, String pendingId)? start,
    TResult Function(String pendingId)? successful,
    TResult Function(Object error, StackTrace stackTrace, String pendingId)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, stackTrace, pendingId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EditPasswordStart value) start,
    required TResult Function(EditPasswordSuccessful value) successful,
    required TResult Function(EditPasswordError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EditPasswordStart value)? start,
    TResult Function(EditPasswordSuccessful value)? successful,
    TResult Function(EditPasswordError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class EditPasswordError implements EditPassword, ActionDone, ErrorAction {
  const factory EditPasswordError(final Object error, final StackTrace stackTrace, [final String pendingId]) =
      _$EditPasswordError;

  Object get error => throw _privateConstructorUsedError;
  StackTrace get stackTrace => throw _privateConstructorUsedError;
  @override
  String get pendingId => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$EditPasswordErrorCopyWith<_$EditPasswordError> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SetScannedCode {
  Code get code => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetScannedCodeCopyWith<SetScannedCode> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetScannedCodeCopyWith<$Res> {
  factory $SetScannedCodeCopyWith(SetScannedCode value, $Res Function(SetScannedCode) then) =
      _$SetScannedCodeCopyWithImpl<$Res>;
  $Res call({Code code});

  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class _$SetScannedCodeCopyWithImpl<$Res> implements $SetScannedCodeCopyWith<$Res> {
  _$SetScannedCodeCopyWithImpl(this._value, this._then);

  final SetScannedCode _value;
  // ignore: unused_field
  final $Res Function(SetScannedCode) _then;

  @override
  $Res call({
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
    ));
  }

  @override
  $CodeCopyWith<$Res> get code {
    return $CodeCopyWith<$Res>(_value.code, (value) {
      return _then(_value.copyWith(code: value));
    });
  }
}

/// @nodoc
abstract class _$$SetScannedCode$CopyWith<$Res> implements $SetScannedCodeCopyWith<$Res> {
  factory _$$SetScannedCode$CopyWith(_$SetScannedCode$ value, $Res Function(_$SetScannedCode$) then) =
      __$$SetScannedCode$CopyWithImpl<$Res>;
  @override
  $Res call({Code code});

  @override
  $CodeCopyWith<$Res> get code;
}

/// @nodoc
class __$$SetScannedCode$CopyWithImpl<$Res> extends _$SetScannedCodeCopyWithImpl<$Res>
    implements _$$SetScannedCode$CopyWith<$Res> {
  __$$SetScannedCode$CopyWithImpl(_$SetScannedCode$ _value, $Res Function(_$SetScannedCode$) _then)
      : super(_value, (v) => _then(v as _$SetScannedCode$));

  @override
  _$SetScannedCode$ get _value => super._value as _$SetScannedCode$;

  @override
  $Res call({
    Object? code = freezed,
  }) {
    return _then(_$SetScannedCode$(
      code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as Code,
    ));
  }
}

/// @nodoc

class _$SetScannedCode$ implements SetScannedCode$ {
  const _$SetScannedCode$(this.code);

  @override
  final Code code;

  @override
  String toString() {
    return 'SetScannedCode(code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetScannedCode$ &&
            const DeepCollectionEquality().equals(other.code, code));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(code));

  @JsonKey(ignore: true)
  @override
  _$$SetScannedCode$CopyWith<_$SetScannedCode$> get copyWith =>
      __$$SetScannedCode$CopyWithImpl<_$SetScannedCode$>(this, _$identity);
}

abstract class SetScannedCode$ implements SetScannedCode {
  const factory SetScannedCode$(final Code code) = _$SetScannedCode$;

  @override
  Code get code => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$SetScannedCode$CopyWith<_$SetScannedCode$> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UpdateAccessTime {
  String get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UpdateAccessTimeCopyWith<UpdateAccessTime> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UpdateAccessTimeCopyWith<$Res> {
  factory $UpdateAccessTimeCopyWith(UpdateAccessTime value, $Res Function(UpdateAccessTime) then) =
      _$UpdateAccessTimeCopyWithImpl<$Res>;
  $Res call({String id});
}

/// @nodoc
class _$UpdateAccessTimeCopyWithImpl<$Res> implements $UpdateAccessTimeCopyWith<$Res> {
  _$UpdateAccessTimeCopyWithImpl(this._value, this._then);

  final UpdateAccessTime _value;
  // ignore: unused_field
  final $Res Function(UpdateAccessTime) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$UpdateAccessTime$CopyWith<$Res> implements $UpdateAccessTimeCopyWith<$Res> {
  factory _$$UpdateAccessTime$CopyWith(_$UpdateAccessTime$ value, $Res Function(_$UpdateAccessTime$) then) =
      __$$UpdateAccessTime$CopyWithImpl<$Res>;
  @override
  $Res call({String id});
}

/// @nodoc
class __$$UpdateAccessTime$CopyWithImpl<$Res> extends _$UpdateAccessTimeCopyWithImpl<$Res>
    implements _$$UpdateAccessTime$CopyWith<$Res> {
  __$$UpdateAccessTime$CopyWithImpl(_$UpdateAccessTime$ _value, $Res Function(_$UpdateAccessTime$) _then)
      : super(_value, (v) => _then(v as _$UpdateAccessTime$));

  @override
  _$UpdateAccessTime$ get _value => super._value as _$UpdateAccessTime$;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_$UpdateAccessTime$(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateAccessTime$ implements UpdateAccessTime$ {
  const _$UpdateAccessTime$(this.id);

  @override
  final String id;

  @override
  String toString() {
    return 'UpdateAccessTime(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateAccessTime$ &&
            const DeepCollectionEquality().equals(other.id, id));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(id));

  @JsonKey(ignore: true)
  @override
  _$$UpdateAccessTime$CopyWith<_$UpdateAccessTime$> get copyWith =>
      __$$UpdateAccessTime$CopyWithImpl<_$UpdateAccessTime$>(this, _$identity);
}

abstract class UpdateAccessTime$ implements UpdateAccessTime {
  const factory UpdateAccessTime$(final String id) = _$UpdateAccessTime$;

  @override
  String get id => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$UpdateAccessTime$CopyWith<_$UpdateAccessTime$> get copyWith => throw _privateConstructorUsedError;
}
